import {
  require_react
} from "./chunk-X6MODOAL.js";
import {
  __toESM
} from "./chunk-J43GMYXM.js";

// node_modules/react-scrollmagic/dist/index.es.js
var import_react = __toESM(require_react());
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
  return typeof obj;
} : function(obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};
var classCallCheck = function(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};
var createClass = function() {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  return function(Constructor, protoProps, staticProps) {
    if (protoProps)
      defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();
var defineProperty = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};
var _extends = Object.assign || function(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
var inherits = function(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass)
    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};
var objectWithoutProperties = function(obj, keys) {
  var target = {};
  for (var i in obj) {
    if (keys.indexOf(i) >= 0)
      continue;
    if (!Object.prototype.hasOwnProperty.call(obj, i))
      continue;
    target[i] = obj[i];
  }
  return target;
};
var possibleConstructorReturn = function(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};
var windowMock = {};
windowMock.addEventListener = function() {
};
var ScrollMagic = function(window2, document2) {
  var ScrollMagic2 = function ScrollMagic3() {
    _util.log(2, "(COMPATIBILITY NOTICE) -> As of ScrollMagic 2.0.0 you need to use 'new ScrollMagic.Controller()' to create a new controller instance. Use 'new ScrollMagic.Scene()' to instance a scene.");
  };
  ScrollMagic2.version = "2.0.7";
  window2.addEventListener("mousewheel", function() {
  });
  var PIN_SPACER_ATTRIBUTE = "data-scrollmagic-pin-spacer";
  ScrollMagic2.Controller = function(options) {
    var NAMESPACE = "ScrollMagic.Controller", SCROLL_DIRECTION_FORWARD = "FORWARD", SCROLL_DIRECTION_REVERSE = "REVERSE", SCROLL_DIRECTION_PAUSED = "PAUSED", DEFAULT_OPTIONS = CONTROLLER_OPTIONS.defaults;
    var Controller2 = this, _options = _util.extend({}, DEFAULT_OPTIONS, options), _sceneObjects = [], _updateScenesOnNextCycle = false, _scrollPos = 0, _scrollDirection = SCROLL_DIRECTION_PAUSED, _isDocument = true, _viewPortSize = 0, _enabled = true, _updateTimeout, _refreshTimeout;
    var construct = function construct2() {
      for (var key in _options) {
        if (!DEFAULT_OPTIONS.hasOwnProperty(key)) {
          log(2, 'WARNING: Unknown option "' + key + '"');
          delete _options[key];
        }
      }
      _options.container = _util.get.elements(_options.container)[0];
      if (!_options.container) {
        log(1, "ERROR creating object " + NAMESPACE + ": No valid scroll container supplied");
        throw NAMESPACE + " init failed.";
      }
      _isDocument = _options.container === window2 || _options.container === document2.body || !document2.body.contains(_options.container);
      if (_isDocument) {
        _options.container = window2;
      }
      _viewPortSize = getViewportSize();
      _options.container.addEventListener("resize", onChange);
      _options.container.addEventListener("scroll", onChange);
      var ri = parseInt(_options.refreshInterval, 10);
      _options.refreshInterval = _util.type.Number(ri) ? ri : DEFAULT_OPTIONS.refreshInterval;
      scheduleRefresh();
      log(3, "added new " + NAMESPACE + " controller (v" + ScrollMagic2.version + ")");
    };
    var scheduleRefresh = function scheduleRefresh2() {
      if (_options.refreshInterval > 0) {
        _refreshTimeout = window2.setTimeout(refresh, _options.refreshInterval);
      }
    };
    var getScrollPos = function getScrollPos2() {
      return _options.vertical ? _util.get.scrollTop(_options.container) : _util.get.scrollLeft(_options.container);
    };
    var getViewportSize = function getViewportSize2() {
      return _options.vertical ? _util.get.height(_options.container) : _util.get.width(_options.container);
    };
    var setScrollPos = this._setScrollPos = function(pos) {
      if (_options.vertical) {
        if (_isDocument) {
          window2.scrollTo(_util.get.scrollLeft(), pos);
        } else {
          _options.container.scrollTop = pos;
        }
      } else {
        if (_isDocument) {
          window2.scrollTo(pos, _util.get.scrollTop());
        } else {
          _options.container.scrollLeft = pos;
        }
      }
    };
    var updateScenes = function updateScenes2() {
      if (_enabled && _updateScenesOnNextCycle) {
        var scenesToUpdate = _util.type.Array(_updateScenesOnNextCycle) ? _updateScenesOnNextCycle : _sceneObjects.slice(0);
        _updateScenesOnNextCycle = false;
        var oldScrollPos = _scrollPos;
        _scrollPos = Controller2.scrollPos();
        var deltaScroll = _scrollPos - oldScrollPos;
        if (deltaScroll !== 0) {
          _scrollDirection = deltaScroll > 0 ? SCROLL_DIRECTION_FORWARD : SCROLL_DIRECTION_REVERSE;
        }
        if (_scrollDirection === SCROLL_DIRECTION_REVERSE) {
          scenesToUpdate.reverse();
        }
        scenesToUpdate.forEach(function(scene, index) {
          log(3, "updating Scene " + (index + 1) + "/" + scenesToUpdate.length + " (" + _sceneObjects.length + " total)");
          scene.update(true);
        });
        if (scenesToUpdate.length === 0 && _options.loglevel >= 3) {
          log(3, "updating 0 Scenes (nothing added to controller)");
        }
      }
    };
    var debounceUpdate = function debounceUpdate2() {
      _updateTimeout = _util.rAF(updateScenes);
    };
    var onChange = function onChange2(e) {
      log(3, "event fired causing an update:", e.type);
      if (e.type == "resize") {
        _viewPortSize = getViewportSize();
        _scrollDirection = SCROLL_DIRECTION_PAUSED;
      }
      if (_updateScenesOnNextCycle !== true) {
        _updateScenesOnNextCycle = true;
        debounceUpdate();
      }
    };
    var refresh = function refresh2() {
      if (!_isDocument) {
        if (_viewPortSize != getViewportSize()) {
          var resizeEvent;
          try {
            resizeEvent = new Event("resize", {
              bubbles: false,
              cancelable: false
            });
          } catch (e) {
            resizeEvent = document2.createEvent("Event");
            resizeEvent.initEvent("resize", false, false);
          }
          _options.container.dispatchEvent(resizeEvent);
        }
      }
      _sceneObjects.forEach(function(scene, index) {
        scene.refresh();
      });
      scheduleRefresh();
    };
    var log = this._log = function(loglevel, output) {
      if (_options.loglevel >= loglevel) {
        Array.prototype.splice.call(arguments, 1, 0, "(" + NAMESPACE + ") ->");
        _util.log.apply(window2, arguments);
      }
    };
    this._options = _options;
    var sortScenes = function sortScenes2(ScenesArray) {
      if (ScenesArray.length <= 1) {
        return ScenesArray;
      } else {
        var scenes = ScenesArray.slice(0);
        scenes.sort(function(a, b) {
          return a.scrollOffset() > b.scrollOffset() ? 1 : -1;
        });
        return scenes;
      }
    };
    this.addScene = function(newScene) {
      if (_util.type.Array(newScene)) {
        newScene.forEach(function(scene, index) {
          Controller2.addScene(scene);
        });
      } else if (newScene instanceof ScrollMagic2.Scene) {
        if (newScene.controller() !== Controller2) {
          newScene.addTo(Controller2);
        } else if (_sceneObjects.indexOf(newScene) < 0) {
          _sceneObjects.push(newScene);
          _sceneObjects = sortScenes(_sceneObjects);
          newScene.on("shift.controller_sort", function() {
            _sceneObjects = sortScenes(_sceneObjects);
          });
          for (var key in _options.globalSceneOptions) {
            if (newScene[key]) {
              newScene[key].call(newScene, _options.globalSceneOptions[key]);
            }
          }
          log(3, "adding Scene (now " + _sceneObjects.length + " total)");
        }
      } else {
        log(1, "ERROR: invalid argument supplied for '.addScene()'");
      }
      return Controller2;
    };
    this.removeScene = function(Scene3) {
      if (_util.type.Array(Scene3)) {
        Scene3.forEach(function(scene, index2) {
          Controller2.removeScene(scene);
        });
      } else {
        var index = _sceneObjects.indexOf(Scene3);
        if (index > -1) {
          Scene3.off("shift.controller_sort");
          _sceneObjects.splice(index, 1);
          log(3, "removing Scene (now " + _sceneObjects.length + " left)");
          Scene3.remove();
        }
      }
      return Controller2;
    };
    this.updateScene = function(Scene3, immediately) {
      if (_util.type.Array(Scene3)) {
        Scene3.forEach(function(scene, index) {
          Controller2.updateScene(scene, immediately);
        });
      } else {
        if (immediately) {
          Scene3.update(true);
        } else if (_updateScenesOnNextCycle !== true && Scene3 instanceof ScrollMagic2.Scene) {
          _updateScenesOnNextCycle = _updateScenesOnNextCycle || [];
          if (_updateScenesOnNextCycle.indexOf(Scene3) == -1) {
            _updateScenesOnNextCycle.push(Scene3);
          }
          _updateScenesOnNextCycle = sortScenes(_updateScenesOnNextCycle);
          debounceUpdate();
        }
      }
      return Controller2;
    };
    this.update = function(immediately) {
      onChange({
        type: "resize"
      });
      if (immediately) {
        updateScenes();
      }
      return Controller2;
    };
    this.scrollTo = function(scrollTarget, additionalParameter) {
      if (_util.type.Number(scrollTarget)) {
        setScrollPos.call(_options.container, scrollTarget, additionalParameter);
      } else if (scrollTarget instanceof ScrollMagic2.Scene) {
        if (scrollTarget.controller() === Controller2) {
          Controller2.scrollTo(scrollTarget.scrollOffset(), additionalParameter);
        } else {
          log(2, "scrollTo(): The supplied scene does not belong to this controller. Scroll cancelled.", scrollTarget);
        }
      } else if (_util.type.Function(scrollTarget)) {
        setScrollPos = scrollTarget;
      } else {
        var elem = _util.get.elements(scrollTarget)[0];
        if (elem) {
          while (elem.parentNode.hasAttribute(PIN_SPACER_ATTRIBUTE)) {
            elem = elem.parentNode;
          }
          var param = _options.vertical ? "top" : "left", containerOffset = _util.get.offset(_options.container), elementOffset = _util.get.offset(elem);
          if (!_isDocument) {
            containerOffset[param] -= Controller2.scrollPos();
          }
          Controller2.scrollTo(elementOffset[param] - containerOffset[param], additionalParameter);
        } else {
          log(2, "scrollTo(): The supplied argument is invalid. Scroll cancelled.", scrollTarget);
        }
      }
      return Controller2;
    };
    this.scrollPos = function(scrollPosMethod) {
      if (!arguments.length) {
        return getScrollPos.call(Controller2);
      } else {
        if (_util.type.Function(scrollPosMethod)) {
          getScrollPos = scrollPosMethod;
        } else {
          log(2, "Provided value for method 'scrollPos' is not a function. To change the current scroll position use 'scrollTo()'.");
        }
      }
      return Controller2;
    };
    this.info = function(about) {
      var values = {
        size: _viewPortSize,
        vertical: _options.vertical,
        scrollPos: _scrollPos,
        scrollDirection: _scrollDirection,
        container: _options.container,
        isDocument: _isDocument
      };
      if (!arguments.length) {
        return values;
      } else if (values[about] !== void 0) {
        return values[about];
      } else {
        log(1, 'ERROR: option "' + about + '" is not available');
        return;
      }
    };
    this.loglevel = function(newLoglevel) {
      if (!arguments.length) {
        return _options.loglevel;
      } else if (_options.loglevel != newLoglevel) {
        _options.loglevel = newLoglevel;
      }
      return Controller2;
    };
    this.enabled = function(newState) {
      if (!arguments.length) {
        return _enabled;
      } else if (_enabled != newState) {
        _enabled = !!newState;
        Controller2.updateScene(_sceneObjects, true);
      }
      return Controller2;
    };
    this.destroy = function(resetScenes) {
      window2.clearTimeout(_refreshTimeout);
      var i = _sceneObjects.length;
      while (i--) {
        _sceneObjects[i].destroy(resetScenes);
      }
      _options.container.removeEventListener("resize", onChange);
      _options.container.removeEventListener("scroll", onChange);
      _util.cAF(_updateTimeout);
      log(3, "destroyed " + NAMESPACE + " (reset: " + (resetScenes ? "true" : "false") + ")");
      return null;
    };
    construct();
    return Controller2;
  };
  var CONTROLLER_OPTIONS = {
    defaults: {
      container: window2,
      vertical: true,
      globalSceneOptions: {},
      loglevel: 2,
      refreshInterval: 100
    }
  };
  ScrollMagic2.Controller.addOption = function(name, defaultValue) {
    CONTROLLER_OPTIONS.defaults[name] = defaultValue;
  };
  ScrollMagic2.Controller.extend = function(extension) {
    var oldClass = this;
    ScrollMagic2.Controller = function() {
      oldClass.apply(this, arguments);
      this.$super = _util.extend({}, this);
      return extension.apply(this, arguments) || this;
    };
    _util.extend(ScrollMagic2.Controller, oldClass);
    ScrollMagic2.Controller.prototype = oldClass.prototype;
    ScrollMagic2.Controller.prototype.constructor = ScrollMagic2.Controller;
  };
  ScrollMagic2.Scene = function(options) {
    var NAMESPACE = "ScrollMagic.Scene", SCENE_STATE_BEFORE = "BEFORE", SCENE_STATE_DURING = "DURING", SCENE_STATE_AFTER = "AFTER", DEFAULT_OPTIONS = SCENE_OPTIONS.defaults;
    var Scene3 = this, _options = _util.extend({}, DEFAULT_OPTIONS, options), _state = SCENE_STATE_BEFORE, _progress = 0, _scrollOffset = {
      start: 0,
      end: 0
    }, _triggerPos = 0, _enabled = true, _durationUpdateMethod, _controller;
    var construct = function construct2() {
      for (var key in _options) {
        if (!DEFAULT_OPTIONS.hasOwnProperty(key)) {
          log(2, 'WARNING: Unknown option "' + key + '"');
          delete _options[key];
        }
      }
      for (var optionName in DEFAULT_OPTIONS) {
        addSceneOption(optionName);
      }
      validateOption();
    };
    var _listeners = {};
    this.on = function(names, callback) {
      if (_util.type.Function(callback)) {
        names = names.trim().split(" ");
        names.forEach(function(fullname) {
          var nameparts = fullname.split("."), eventname = nameparts[0], namespace = nameparts[1];
          if (eventname != "*") {
            if (!_listeners[eventname]) {
              _listeners[eventname] = [];
            }
            _listeners[eventname].push({
              namespace: namespace || "",
              callback
            });
          }
        });
      } else {
        log(1, "ERROR when calling '.on()': Supplied callback for '" + names + "' is not a valid function!");
      }
      return Scene3;
    };
    this.off = function(names, callback) {
      if (!names) {
        log(1, "ERROR: Invalid event name supplied.");
        return Scene3;
      }
      names = names.trim().split(" ");
      names.forEach(function(fullname, key) {
        var nameparts = fullname.split("."), eventname = nameparts[0], namespace = nameparts[1] || "", removeList = eventname === "*" ? Object.keys(_listeners) : [eventname];
        removeList.forEach(function(remove) {
          var list = _listeners[remove] || [], i = list.length;
          while (i--) {
            var listener = list[i];
            if (listener && (namespace === listener.namespace || namespace === "*") && (!callback || callback == listener.callback)) {
              list.splice(i, 1);
            }
          }
          if (!list.length) {
            delete _listeners[remove];
          }
        });
      });
      return Scene3;
    };
    this.trigger = function(name, vars) {
      if (name) {
        var nameparts = name.trim().split("."), eventname = nameparts[0], namespace = nameparts[1], listeners = _listeners[eventname];
        log(3, "event fired:", eventname, vars ? "->" : "", vars || "");
        if (listeners) {
          listeners.forEach(function(listener, key) {
            if (!namespace || namespace === listener.namespace) {
              listener.callback.call(Scene3, new ScrollMagic2.Event(eventname, listener.namespace, Scene3, vars));
            }
          });
        }
      } else {
        log(1, "ERROR: Invalid event name supplied.");
      }
      return Scene3;
    };
    Scene3.on("change.internal", function(e) {
      if (e.what !== "loglevel" && e.what !== "tweenChanges") {
        if (e.what === "triggerElement") {
          updateTriggerElementPosition();
        } else if (e.what === "reverse") {
          Scene3.update();
        }
      }
    }).on("shift.internal", function(e) {
      updateScrollOffset();
      Scene3.update();
    });
    var log = this._log = function(loglevel, output) {
      if (_options.loglevel >= loglevel) {
        Array.prototype.splice.call(arguments, 1, 0, "(" + NAMESPACE + ") ->");
        _util.log.apply(window2, arguments);
      }
    };
    this.addTo = function(controller) {
      if (!(controller instanceof ScrollMagic2.Controller)) {
        log(1, "ERROR: supplied argument of 'addTo()' is not a valid ScrollMagic Controller");
      } else if (_controller != controller) {
        if (_controller) {
          _controller.removeScene(Scene3);
        }
        _controller = controller;
        validateOption();
        updateDuration(true);
        updateTriggerElementPosition(true);
        updateScrollOffset();
        _controller.info("container").addEventListener("resize", onContainerResize);
        controller.addScene(Scene3);
        Scene3.trigger("add", {
          controller: _controller
        });
        log(3, "added " + NAMESPACE + " to controller");
        Scene3.update();
      }
      return Scene3;
    };
    this.enabled = function(newState) {
      if (!arguments.length) {
        return _enabled;
      } else if (_enabled != newState) {
        _enabled = !!newState;
        Scene3.update(true);
      }
      return Scene3;
    };
    this.remove = function() {
      if (_controller) {
        _controller.info("container").removeEventListener("resize", onContainerResize);
        var tmpParent = _controller;
        _controller = void 0;
        tmpParent.removeScene(Scene3);
        Scene3.trigger("remove");
        log(3, "removed " + NAMESPACE + " from controller");
      }
      return Scene3;
    };
    this.destroy = function(reset) {
      Scene3.trigger("destroy", {
        reset
      });
      Scene3.remove();
      Scene3.off("*.*");
      log(3, "destroyed " + NAMESPACE + " (reset: " + (reset ? "true" : "false") + ")");
      return null;
    };
    this.update = function(immediately) {
      if (_controller) {
        if (immediately) {
          if (_controller.enabled() && _enabled) {
            var scrollPos = _controller.info("scrollPos"), newProgress;
            if (_options.duration > 0) {
              newProgress = (scrollPos - _scrollOffset.start) / (_scrollOffset.end - _scrollOffset.start);
            } else {
              newProgress = scrollPos >= _scrollOffset.start ? 1 : 0;
            }
            Scene3.trigger("update", {
              startPos: _scrollOffset.start,
              endPos: _scrollOffset.end,
              scrollPos
            });
            Scene3.progress(newProgress);
          } else if (_pin && _state === SCENE_STATE_DURING) {
            updatePinState(true);
          }
        } else {
          _controller.updateScene(Scene3, false);
        }
      }
      return Scene3;
    };
    this.refresh = function() {
      updateDuration();
      updateTriggerElementPosition();
      return Scene3;
    };
    this.progress = function(progress) {
      if (!arguments.length) {
        return _progress;
      } else {
        var doUpdate = false, oldState = _state, scrollDirection = _controller ? _controller.info("scrollDirection") : "PAUSED", reverseOrForward = _options.reverse || progress >= _progress;
        if (_options.duration === 0) {
          doUpdate = _progress != progress;
          _progress = progress < 1 && reverseOrForward ? 0 : 1;
          _state = _progress === 0 ? SCENE_STATE_BEFORE : SCENE_STATE_DURING;
        } else {
          if (progress < 0 && _state !== SCENE_STATE_BEFORE && reverseOrForward) {
            _progress = 0;
            _state = SCENE_STATE_BEFORE;
            doUpdate = true;
          } else if (progress >= 0 && progress < 1 && reverseOrForward) {
            _progress = progress;
            _state = SCENE_STATE_DURING;
            doUpdate = true;
          } else if (progress >= 1 && _state !== SCENE_STATE_AFTER) {
            _progress = 1;
            _state = SCENE_STATE_AFTER;
            doUpdate = true;
          } else if (_state === SCENE_STATE_DURING && !reverseOrForward) {
            updatePinState();
          }
        }
        if (doUpdate) {
          var eventVars = {
            progress: _progress,
            state: _state,
            scrollDirection
          }, stateChanged = _state != oldState;
          var trigger = function trigger2(eventName) {
            Scene3.trigger(eventName, eventVars);
          };
          if (stateChanged) {
            if (oldState !== SCENE_STATE_DURING) {
              trigger("enter");
              trigger(oldState === SCENE_STATE_BEFORE ? "start" : "end");
            }
          }
          trigger("progress");
          if (stateChanged) {
            if (_state !== SCENE_STATE_DURING) {
              trigger(_state === SCENE_STATE_BEFORE ? "start" : "end");
              trigger("leave");
            }
          }
        }
        return Scene3;
      }
    };
    var updateScrollOffset = function updateScrollOffset2() {
      _scrollOffset = {
        start: _triggerPos + _options.offset
      };
      if (_controller && _options.triggerElement) {
        _scrollOffset.start -= _controller.info("size") * _options.triggerHook;
      }
      _scrollOffset.end = _scrollOffset.start + _options.duration;
    };
    var updateDuration = function updateDuration2(suppressEvents) {
      if (_durationUpdateMethod) {
        var varname = "duration";
        if (changeOption(varname, _durationUpdateMethod.call(Scene3)) && !suppressEvents) {
          Scene3.trigger("change", {
            what: varname,
            newval: _options[varname]
          });
          Scene3.trigger("shift", {
            reason: varname
          });
        }
      }
    };
    var updateTriggerElementPosition = function updateTriggerElementPosition2(suppressEvents) {
      var elementPos = 0, telem = _options.triggerElement;
      if (_controller && (telem || _triggerPos > 0)) {
        if (telem) {
          if (telem.parentNode) {
            var controllerInfo = _controller.info(), containerOffset = _util.get.offset(controllerInfo.container), param = controllerInfo.vertical ? "top" : "left";
            while (telem.parentNode.hasAttribute(PIN_SPACER_ATTRIBUTE)) {
              telem = telem.parentNode;
            }
            var elementOffset = _util.get.offset(telem);
            if (!controllerInfo.isDocument) {
              containerOffset[param] -= _controller.scrollPos();
            }
            elementPos = elementOffset[param] - containerOffset[param];
          } else {
            log(2, "WARNING: triggerElement was removed from DOM and will be reset to", void 0);
            Scene3.triggerElement(void 0);
          }
        }
        var changed = elementPos != _triggerPos;
        _triggerPos = elementPos;
        if (changed && !suppressEvents) {
          Scene3.trigger("shift", {
            reason: "triggerElementPosition"
          });
        }
      }
    };
    var onContainerResize = function onContainerResize2(e) {
      if (_options.triggerHook > 0) {
        Scene3.trigger("shift", {
          reason: "containerResize"
        });
      }
    };
    var _validate = _util.extend(SCENE_OPTIONS.validate, {
      duration: function duration(val) {
        if (_util.type.String(val) && val.match(/^(\.|\d)*\d+%$/)) {
          var perc = parseFloat(val) / 100;
          val = function val2() {
            return _controller ? _controller.info("size") * perc : 0;
          };
        }
        if (_util.type.Function(val)) {
          _durationUpdateMethod = val;
          try {
            val = parseFloat(_durationUpdateMethod.call(Scene3));
          } catch (e) {
            val = -1;
          }
        }
        val = parseFloat(val);
        if (!_util.type.Number(val) || val < 0) {
          if (_durationUpdateMethod) {
            _durationUpdateMethod = void 0;
            throw ['Invalid return value of supplied function for option "duration":', val];
          } else {
            throw ['Invalid value for option "duration":', val];
          }
        }
        return val;
      }
    });
    var validateOption = function validateOption2(check) {
      check = arguments.length ? [check] : Object.keys(_validate);
      check.forEach(function(optionName, key) {
        var value;
        if (_validate[optionName]) {
          try {
            value = _validate[optionName](_options[optionName]);
          } catch (e) {
            value = DEFAULT_OPTIONS[optionName];
            var logMSG = _util.type.String(e) ? [e] : e;
            if (_util.type.Array(logMSG)) {
              logMSG[0] = "ERROR: " + logMSG[0];
              logMSG.unshift(1);
              log.apply(this, logMSG);
            } else {
              log(1, "ERROR: Problem executing validation callback for option '" + optionName + "':", e.message);
            }
          } finally {
            _options[optionName] = value;
          }
        }
      });
    };
    var changeOption = function changeOption2(varname, newval) {
      var changed = false, oldval = _options[varname];
      if (_options[varname] != newval) {
        _options[varname] = newval;
        validateOption(varname);
        changed = oldval != _options[varname];
      }
      return changed;
    };
    var addSceneOption = function addSceneOption2(optionName) {
      if (!Scene3[optionName]) {
        Scene3[optionName] = function(newVal) {
          if (!arguments.length) {
            return _options[optionName];
          } else {
            if (optionName === "duration") {
              _durationUpdateMethod = void 0;
            }
            if (changeOption(optionName, newVal)) {
              Scene3.trigger("change", {
                what: optionName,
                newval: _options[optionName]
              });
              if (SCENE_OPTIONS.shifts.indexOf(optionName) > -1) {
                Scene3.trigger("shift", {
                  reason: optionName
                });
              }
            }
          }
          return Scene3;
        };
      }
    };
    this.controller = function() {
      return _controller;
    };
    this.state = function() {
      return _state;
    };
    this.scrollOffset = function() {
      return _scrollOffset.start;
    };
    this.triggerPosition = function() {
      var pos = _options.offset;
      if (_controller) {
        if (_options.triggerElement) {
          pos += _triggerPos;
        } else {
          pos += _controller.info("size") * Scene3.triggerHook();
        }
      }
      return pos;
    };
    var _pin, _pinOptions;
    Scene3.on("shift.internal", function(e) {
      var durationChanged = e.reason === "duration";
      if (_state === SCENE_STATE_AFTER && durationChanged || _state === SCENE_STATE_DURING && _options.duration === 0) {
        updatePinState();
      }
      if (durationChanged) {
        updatePinDimensions();
      }
    }).on("progress.internal", function(e) {
      updatePinState();
    }).on("add.internal", function(e) {
      updatePinDimensions();
    }).on("destroy.internal", function(e) {
      Scene3.removePin(e.reset);
    });
    var updatePinState = function updatePinState2(forceUnpin) {
      if (_pin && _controller) {
        var containerInfo = _controller.info(), pinTarget = _pinOptions.spacer.firstChild;
        if (!forceUnpin && _state === SCENE_STATE_DURING) {
          if (_util.css(pinTarget, "position") != "fixed") {
            _util.css(pinTarget, {
              "position": "fixed"
            });
            updatePinDimensions();
          }
          var fixedPos = _util.get.offset(_pinOptions.spacer, true), scrollDistance = _options.reverse || _options.duration === 0 ? containerInfo.scrollPos - _scrollOffset.start : Math.round(_progress * _options.duration * 10) / 10;
          fixedPos[containerInfo.vertical ? "top" : "left"] += scrollDistance;
          _util.css(_pinOptions.spacer.firstChild, {
            top: fixedPos.top,
            left: fixedPos.left
          });
        } else {
          var newCSS = {
            position: _pinOptions.inFlow ? "relative" : "absolute",
            top: 0,
            left: 0
          }, change = _util.css(pinTarget, "position") != newCSS.position;
          if (!_pinOptions.pushFollowers) {
            newCSS[containerInfo.vertical ? "top" : "left"] = _options.duration * _progress;
          } else if (_options.duration > 0) {
            if (_state === SCENE_STATE_AFTER && parseFloat(_util.css(_pinOptions.spacer, "padding-top")) === 0) {
              change = true;
            } else if (_state === SCENE_STATE_BEFORE && parseFloat(_util.css(_pinOptions.spacer, "padding-bottom")) === 0) {
              change = true;
            }
          }
          _util.css(pinTarget, newCSS);
          if (change) {
            updatePinDimensions();
          }
        }
      }
    };
    var updatePinDimensions = function updatePinDimensions2() {
      if (_pin && _controller && _pinOptions.inFlow) {
        var during = _state === SCENE_STATE_DURING, vertical = _controller.info("vertical"), pinTarget = _pinOptions.spacer.firstChild, marginCollapse = _util.isMarginCollapseType(_util.css(_pinOptions.spacer, "display")), css = {};
        if (_pinOptions.relSize.width || _pinOptions.relSize.autoFullWidth) {
          if (during) {
            _util.css(_pin, {
              "width": _util.get.width(_pinOptions.spacer)
            });
          } else {
            _util.css(_pin, {
              "width": "100%"
            });
          }
        } else {
          css["min-width"] = _util.get.width(vertical ? _pin : pinTarget, true, true);
          css.width = during ? css["min-width"] : "auto";
        }
        if (_pinOptions.relSize.height) {
          if (during) {
            _util.css(_pin, {
              "height": _util.get.height(_pinOptions.spacer) - (_pinOptions.pushFollowers ? _options.duration : 0)
            });
          } else {
            _util.css(_pin, {
              "height": "100%"
            });
          }
        } else {
          css["min-height"] = _util.get.height(vertical ? pinTarget : _pin, true, !marginCollapse);
          css.height = during ? css["min-height"] : "auto";
        }
        if (_pinOptions.pushFollowers) {
          css["padding" + (vertical ? "Top" : "Left")] = _options.duration * _progress;
          css["padding" + (vertical ? "Bottom" : "Right")] = _options.duration * (1 - _progress);
        }
        _util.css(_pinOptions.spacer, css);
      }
    };
    var updatePinInContainer = function updatePinInContainer2() {
      if (_controller && _pin && _state === SCENE_STATE_DURING && !_controller.info("isDocument")) {
        updatePinState();
      }
    };
    var updateRelativePinSpacer = function updateRelativePinSpacer2() {
      if (_controller && _pin && _state === SCENE_STATE_DURING && ((_pinOptions.relSize.width || _pinOptions.relSize.autoFullWidth) && _util.get.width(window2) != _util.get.width(_pinOptions.spacer.parentNode) || _pinOptions.relSize.height && _util.get.height(window2) != _util.get.height(_pinOptions.spacer.parentNode))) {
        updatePinDimensions();
      }
    };
    var onMousewheelOverPin = function onMousewheelOverPin2(e) {
      if (_controller && _pin && _state === SCENE_STATE_DURING && !_controller.info("isDocument")) {
        e.preventDefault();
        _controller._setScrollPos(_controller.info("scrollPos") - ((e.wheelDelta || e[_controller.info("vertical") ? "wheelDeltaY" : "wheelDeltaX"]) / 3 || -e.detail * 30));
      }
    };
    this.setPin = function(element, settings) {
      var defaultSettings = {
        pushFollowers: true,
        spacerClass: "scrollmagic-pin-spacer"
      };
      var pushFollowersActivelySet = settings && settings.hasOwnProperty("pushFollowers");
      settings = _util.extend({}, defaultSettings, settings);
      element = _util.get.elements(element)[0];
      if (!element) {
        log(1, "ERROR calling method 'setPin()': Invalid pin element supplied.");
        return Scene3;
      } else if (_util.css(element, "position") === "fixed") {
        log(1, "ERROR calling method 'setPin()': Pin does not work with elements that are positioned 'fixed'.");
        return Scene3;
      }
      if (_pin) {
        if (_pin === element) {
          return Scene3;
        } else {
          Scene3.removePin();
        }
      }
      _pin = element;
      var parentDisplay = _pin.parentNode.style.display, boundsParams = ["top", "left", "bottom", "right", "margin", "marginLeft", "marginRight", "marginTop", "marginBottom"];
      _pin.parentNode.style.display = "none";
      var inFlow = _util.css(_pin, "position") != "absolute", pinCSS = _util.css(_pin, boundsParams.concat(["display"])), sizeCSS = _util.css(_pin, ["width", "height"]);
      _pin.parentNode.style.display = parentDisplay;
      if (!inFlow && settings.pushFollowers) {
        log(2, "WARNING: If the pinned element is positioned absolutely pushFollowers will be disabled.");
        settings.pushFollowers = false;
      }
      window2.setTimeout(function() {
        if (_pin && _options.duration === 0 && pushFollowersActivelySet && settings.pushFollowers) {
          log(2, "WARNING: pushFollowers =", true, "has no effect, when scene duration is 0.");
        }
      }, 0);
      var spacer = _pin.parentNode.insertBefore(document2.createElement("div"), _pin), spacerCSS = _util.extend(pinCSS, {
        position: inFlow ? "relative" : "absolute",
        boxSizing: "content-box",
        mozBoxSizing: "content-box",
        webkitBoxSizing: "content-box"
      });
      if (!inFlow) {
        _util.extend(spacerCSS, _util.css(_pin, ["width", "height"]));
      }
      _util.css(spacer, spacerCSS);
      spacer.setAttribute(PIN_SPACER_ATTRIBUTE, "");
      _util.addClass(spacer, settings.spacerClass);
      _pinOptions = {
        spacer,
        relSize: {
          width: sizeCSS.width.slice(-1) === "%",
          height: sizeCSS.height.slice(-1) === "%",
          autoFullWidth: sizeCSS.width === "auto" && inFlow && _util.isMarginCollapseType(pinCSS.display)
        },
        pushFollowers: settings.pushFollowers,
        inFlow
      };
      if (!_pin.___origStyle) {
        _pin.___origStyle = {};
        var pinInlineCSS = _pin.style, copyStyles = boundsParams.concat(["width", "height", "position", "boxSizing", "mozBoxSizing", "webkitBoxSizing"]);
        copyStyles.forEach(function(val) {
          _pin.___origStyle[val] = pinInlineCSS[val] || "";
        });
      }
      if (_pinOptions.relSize.width) {
        _util.css(spacer, {
          width: sizeCSS.width
        });
      }
      if (_pinOptions.relSize.height) {
        _util.css(spacer, {
          height: sizeCSS.height
        });
      }
      spacer.appendChild(_pin);
      _util.css(_pin, {
        position: inFlow ? "relative" : "absolute",
        margin: "auto",
        top: "auto",
        left: "auto",
        bottom: "auto",
        right: "auto"
      });
      if (_pinOptions.relSize.width || _pinOptions.relSize.autoFullWidth) {
        _util.css(_pin, {
          boxSizing: "border-box",
          mozBoxSizing: "border-box",
          webkitBoxSizing: "border-box"
        });
      }
      window2.addEventListener("scroll", updatePinInContainer);
      window2.addEventListener("resize", updatePinInContainer);
      window2.addEventListener("resize", updateRelativePinSpacer);
      _pin.addEventListener("mousewheel", onMousewheelOverPin);
      _pin.addEventListener("DOMMouseScroll", onMousewheelOverPin);
      log(3, "added pin");
      updatePinState();
      return Scene3;
    };
    this.removePin = function(reset) {
      if (_pin) {
        if (_state === SCENE_STATE_DURING) {
          updatePinState(true);
        }
        if (reset || !_controller) {
          var pinTarget = _pinOptions.spacer.firstChild;
          if (pinTarget.hasAttribute(PIN_SPACER_ATTRIBUTE)) {
            var style = _pinOptions.spacer.style, values = ["margin", "marginLeft", "marginRight", "marginTop", "marginBottom"], margins = {};
            values.forEach(function(val) {
              margins[val] = style[val] || "";
            });
            _util.css(pinTarget, margins);
          }
          _pinOptions.spacer.parentNode.insertBefore(pinTarget, _pinOptions.spacer);
          _pinOptions.spacer.parentNode.removeChild(_pinOptions.spacer);
          if (!_pin.parentNode.hasAttribute(PIN_SPACER_ATTRIBUTE)) {
            _util.css(_pin, _pin.___origStyle);
            delete _pin.___origStyle;
          }
        }
        window2.removeEventListener("scroll", updatePinInContainer);
        window2.removeEventListener("resize", updatePinInContainer);
        window2.removeEventListener("resize", updateRelativePinSpacer);
        _pin.removeEventListener("mousewheel", onMousewheelOverPin);
        _pin.removeEventListener("DOMMouseScroll", onMousewheelOverPin);
        _pin = void 0;
        log(3, "removed pin (reset: " + (reset ? "true" : "false") + ")");
      }
      return Scene3;
    };
    var _cssClasses, _cssClassElems = [];
    Scene3.on("destroy.internal", function(e) {
      Scene3.removeClassToggle(e.reset);
    });
    this.setClassToggle = function(element, classes) {
      var elems = _util.get.elements(element);
      if (elems.length === 0 || !_util.type.String(classes)) {
        log(1, "ERROR calling method 'setClassToggle()': Invalid " + (elems.length === 0 ? "element" : "classes") + " supplied.");
        return Scene3;
      }
      if (_cssClassElems.length > 0) {
        Scene3.removeClassToggle();
      }
      _cssClasses = classes;
      _cssClassElems = elems;
      Scene3.on("enter.internal_class leave.internal_class", function(e) {
        var toggle = e.type === "enter" ? _util.addClass : _util.removeClass;
        _cssClassElems.forEach(function(elem, key) {
          toggle(elem, _cssClasses);
        });
      });
      return Scene3;
    };
    this.removeClassToggle = function(reset) {
      if (reset) {
        _cssClassElems.forEach(function(elem, key) {
          _util.removeClass(elem, _cssClasses);
        });
      }
      Scene3.off("start.internal_class end.internal_class");
      _cssClasses = void 0;
      _cssClassElems = [];
      return Scene3;
    };
    construct();
    return Scene3;
  };
  var SCENE_OPTIONS = {
    defaults: {
      duration: 0,
      offset: 0,
      triggerElement: void 0,
      triggerHook: 0.5,
      reverse: true,
      loglevel: 2
    },
    validate: {
      offset: function offset(val) {
        val = parseFloat(val);
        if (!_util.type.Number(val)) {
          throw ['Invalid value for option "offset":', val];
        }
        return val;
      },
      triggerElement: function triggerElement(val) {
        val = val || void 0;
        if (val) {
          var elem = _util.get.elements(val)[0];
          if (elem && elem.parentNode) {
            val = elem;
          } else {
            throw ['Element defined in option "triggerElement" was not found:', val];
          }
        }
        return val;
      },
      triggerHook: function triggerHook(val) {
        var translate = {
          "onCenter": 0.5,
          "onEnter": 1,
          "onLeave": 0
        };
        if (_util.type.Number(val)) {
          val = Math.max(0, Math.min(parseFloat(val), 1));
        } else if (val in translate) {
          val = translate[val];
        } else {
          throw ['Invalid value for option "triggerHook": ', val];
        }
        return val;
      },
      reverse: function reverse(val) {
        return !!val;
      },
      loglevel: function loglevel(val) {
        val = parseInt(val);
        if (!_util.type.Number(val) || val < 0 || val > 3) {
          throw ['Invalid value for option "loglevel":', val];
        }
        return val;
      }
    },
    shifts: ["duration", "offset", "triggerHook"]
  };
  ScrollMagic2.Scene.addOption = function(name, defaultValue, validationCallback, shifts) {
    if (!(name in SCENE_OPTIONS.defaults)) {
      SCENE_OPTIONS.defaults[name] = defaultValue;
      SCENE_OPTIONS.validate[name] = validationCallback;
      if (shifts) {
        SCENE_OPTIONS.shifts.push(name);
      }
    } else {
      ScrollMagic2._util.log(1, "[static] ScrollMagic.Scene -> Cannot add Scene option '" + name + "', because it already exists.");
    }
  };
  ScrollMagic2.Scene.extend = function(extension) {
    var oldClass = this;
    ScrollMagic2.Scene = function() {
      oldClass.apply(this, arguments);
      this.$super = _util.extend({}, this);
      return extension.apply(this, arguments) || this;
    };
    _util.extend(ScrollMagic2.Scene, oldClass);
    ScrollMagic2.Scene.prototype = oldClass.prototype;
    ScrollMagic2.Scene.prototype.constructor = ScrollMagic2.Scene;
  };
  ScrollMagic2.Event = function(type, namespace, target, vars) {
    vars = vars || {};
    for (var key in vars) {
      this[key] = vars[key];
    }
    this.type = type;
    this.target = this.currentTarget = target;
    this.namespace = namespace || "";
    this.timeStamp = this.timestamp = Date.now();
    return this;
  };
  var _util = ScrollMagic2._util = function(window3) {
    var U = {}, i;
    var floatval = function floatval2(number) {
      return parseFloat(number) || 0;
    };
    var _getComputedStyle = function _getComputedStyle2(elem) {
      return elem.currentStyle ? elem.currentStyle : window3.getComputedStyle(elem);
    };
    var _dimension = function _dimension2(which, elem, outer, includeMargin) {
      elem = elem === document2 ? window3 : elem;
      if (elem === window3) {
        includeMargin = false;
      } else if (!_type.DomElement(elem)) {
        return 0;
      }
      which = which.charAt(0).toUpperCase() + which.substr(1).toLowerCase();
      var dimension = (outer ? elem["offset" + which] || elem["outer" + which] : elem["client" + which] || elem["inner" + which]) || 0;
      if (outer && includeMargin) {
        var style = _getComputedStyle(elem);
        dimension += which === "Height" ? floatval(style.marginTop) + floatval(style.marginBottom) : floatval(style.marginLeft) + floatval(style.marginRight);
      }
      return dimension;
    };
    var _camelCase = function _camelCase2(str) {
      return str.replace(/^[^a-z]+([a-z])/g, "$1").replace(/-([a-z])/g, function(g) {
        return g[1].toUpperCase();
      });
    };
    U.extend = function(obj) {
      obj = obj || {};
      for (i = 1; i < arguments.length; i++) {
        if (!arguments[i]) {
          continue;
        }
        for (var key in arguments[i]) {
          if (arguments[i].hasOwnProperty(key)) {
            obj[key] = arguments[i][key];
          }
        }
      }
      return obj;
    };
    U.isMarginCollapseType = function(str) {
      return ["block", "flex", "list-item", "table", "-webkit-box"].indexOf(str) > -1;
    };
    var lastTime = 0, vendors = ["ms", "moz", "webkit", "o"];
    var _requestAnimationFrame = window3.requestAnimationFrame;
    var _cancelAnimationFrame = window3.cancelAnimationFrame;
    for (i = 0; !_requestAnimationFrame && i < vendors.length; ++i) {
      _requestAnimationFrame = window3[vendors[i] + "RequestAnimationFrame"];
      _cancelAnimationFrame = window3[vendors[i] + "CancelAnimationFrame"] || window3[vendors[i] + "CancelRequestAnimationFrame"];
    }
    if (!_requestAnimationFrame) {
      _requestAnimationFrame = function _requestAnimationFrame2(callback) {
        var currTime = new Date().getTime(), timeToCall = Math.max(0, 16 - (currTime - lastTime)), id = window3.setTimeout(function() {
          callback(currTime + timeToCall);
        }, timeToCall);
        lastTime = currTime + timeToCall;
        return id;
      };
    }
    if (!_cancelAnimationFrame) {
      _cancelAnimationFrame = function _cancelAnimationFrame2(id) {
        window3.clearTimeout(id);
      };
    }
    U.rAF = _requestAnimationFrame.bind(window3);
    U.cAF = _cancelAnimationFrame.bind(window3);
    var loglevels = ["error", "warn", "log"], console = window3.console || {};
    console.log = console.log || function() {
    };
    for (i = 0; i < loglevels.length; i++) {
      var method = loglevels[i];
      if (!console[method]) {
        console[method] = console.log;
      }
    }
    U.log = function(loglevel) {
      if (loglevel > loglevels.length || loglevel <= 0)
        loglevel = loglevels.length;
      var now = new Date(), time = ("0" + now.getHours()).slice(-2) + ":" + ("0" + now.getMinutes()).slice(-2) + ":" + ("0" + now.getSeconds()).slice(-2) + ":" + ("00" + now.getMilliseconds()).slice(-3), method2 = loglevels[loglevel - 1], args = Array.prototype.splice.call(arguments, 1), func = Function.prototype.bind.call(console[method2], console);
      args.unshift(time);
      func.apply(console, args);
    };
    var _type = U.type = function(v) {
      return Object.prototype.toString.call(v).replace(/^\[object (.+)\]$/, "$1").toLowerCase();
    };
    _type.String = function(v) {
      return _type(v) === "string";
    };
    _type.Function = function(v) {
      return _type(v) === "function";
    };
    _type.Array = function(v) {
      return Array.isArray(v);
    };
    _type.Number = function(v) {
      return !_type.Array(v) && v - parseFloat(v) + 1 >= 0;
    };
    _type.DomElement = function(o) {
      return (typeof HTMLElement === "undefined" ? "undefined" : _typeof(HTMLElement)) === "object" || typeof HTMLElement === "function" ? o instanceof HTMLElement || o instanceof SVGElement : o && (typeof o === "undefined" ? "undefined" : _typeof(o)) === "object" && o !== null && o.nodeType === 1 && typeof o.nodeName === "string";
    };
    var _get = U.get = {};
    _get.elements = function(selector) {
      var arr = [];
      if (_type.String(selector)) {
        try {
          selector = document2.querySelectorAll(selector);
        } catch (e) {
          return arr;
        }
      }
      if (_type(selector) === "nodelist" || _type.Array(selector) || selector instanceof NodeList) {
        for (var i2 = 0, ref = arr.length = selector.length; i2 < ref; i2++) {
          var elem = selector[i2];
          arr[i2] = _type.DomElement(elem) ? elem : _get.elements(elem);
        }
      } else if (_type.DomElement(selector) || selector === document2 || selector === window3) {
        arr = [selector];
      }
      return arr;
    };
    _get.scrollTop = function(elem) {
      return elem && typeof elem.scrollTop === "number" ? elem.scrollTop : window3.pageYOffset || 0;
    };
    _get.scrollLeft = function(elem) {
      return elem && typeof elem.scrollLeft === "number" ? elem.scrollLeft : window3.pageXOffset || 0;
    };
    _get.width = function(elem, outer, includeMargin) {
      return _dimension("width", elem, outer, includeMargin);
    };
    _get.height = function(elem, outer, includeMargin) {
      return _dimension("height", elem, outer, includeMargin);
    };
    _get.offset = function(elem, relativeToViewport) {
      var offset = {
        top: 0,
        left: 0
      };
      if (elem && elem.getBoundingClientRect) {
        var rect = elem.getBoundingClientRect();
        offset.top = rect.top;
        offset.left = rect.left;
        if (!relativeToViewport) {
          offset.top += _get.scrollTop();
          offset.left += _get.scrollLeft();
        }
      }
      return offset;
    };
    U.addClass = function(elem, classname) {
      if (classname) {
        if (elem.classList)
          elem.classList.add(classname);
        else
          elem.className += " " + classname;
      }
    };
    U.removeClass = function(elem, classname) {
      if (classname) {
        if (elem.classList)
          elem.classList.remove(classname);
        else
          elem.className = elem.className.replace(new RegExp("(^|\\b)" + classname.split(" ").join("|") + "(\\b|$)", "gi"), " ");
      }
    };
    U.css = function(elem, options) {
      if (_type.String(options)) {
        return _getComputedStyle(elem)[_camelCase(options)];
      } else if (_type.Array(options)) {
        var obj = {}, style = _getComputedStyle(elem);
        options.forEach(function(option2, key) {
          obj[option2] = style[_camelCase(option2)];
        });
        return obj;
      } else {
        for (var option in options) {
          var val = options[option];
          if (val == parseFloat(val)) {
            val += "px";
          }
          elem.style[_camelCase(option)] = val;
        }
      }
    };
    return U;
  }(window2 || {});
  return ScrollMagic2;
}(typeof window === "undefined" ? windowMock : window, typeof document === "undefined" ? {} : document);
var ControllerContext = import_react.default.createContext(null);
var Controller = function(_React$Component) {
  inherits(Controller2, _React$Component);
  function Controller2() {
    var _ref;
    var _temp, _this, _ret;
    classCallCheck(this, Controller2);
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = Controller2.__proto__ || Object.getPrototypeOf(Controller2)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      controller: null
    }, _temp), possibleConstructorReturn(_this, _ret);
  }
  createClass(Controller2, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var _props = this.props, children = _props.children, controllerProps = objectWithoutProperties(_props, ["children"]);
      this.setState({
        controller: new ScrollMagic.Controller(controllerProps)
      });
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.controller = null;
    }
  }, {
    key: "render",
    value: function render() {
      var children = this.props.children;
      var controller = this.state.controller;
      if (!controller) {
        return children;
      }
      return import_react.default.createElement(
        ControllerContext.Provider,
        { value: controller },
        children
      );
    }
  }]);
  return Controller2;
}(import_react.default.Component);
function debugAddIndicators(ScrollMagic2) {
  var NAMESPACE = "debug.addIndicators";
  if (typeof window2 === "undefined") {
    var window2 = {};
    window2.addEventListener = function() {
    };
  }
  var console = window2.console || {}, err = Function.prototype.bind.call(console.error || console.log || function() {
  }, console);
  if (!ScrollMagic2) {
    err("(" + NAMESPACE + ") -> ERROR: The ScrollMagic main module could not be found. Please make sure it's loaded before this plugin or use an asynchronous loader like requirejs.");
  }
  var FONT_SIZE = "0.85em", ZINDEX = "9999", EDGE_OFFSET = 15;
  var _util = ScrollMagic2._util, _autoindex = 0;
  ScrollMagic2.Scene.extend(function() {
    var Scene3 = this, _indicator;
    Scene3.addIndicators = function(options) {
      if (!_indicator) {
        var DEFAULT_OPTIONS = {
          name: "",
          indent: 0,
          parent: void 0,
          colorStart: "green",
          colorEnd: "red",
          colorTrigger: "blue"
        };
        options = _util.extend({}, DEFAULT_OPTIONS, options);
        _autoindex++;
        _indicator = new Indicator(Scene3, options);
        Scene3.on("add.plugin_addIndicators", _indicator.add);
        Scene3.on("remove.plugin_addIndicators", _indicator.remove);
        Scene3.on("destroy.plugin_addIndicators", Scene3.removeIndicators);
        if (Scene3.controller()) {
          _indicator.add();
        }
      }
      return Scene3;
    };
    Scene3.removeIndicators = function() {
      if (_indicator) {
        _indicator.remove();
        this.off("*.plugin_addIndicators");
        _indicator = void 0;
      }
      return Scene3;
    };
  });
  ScrollMagic2.Controller.addOption("addIndicators", false);
  ScrollMagic2.Controller.extend(function() {
    var Controller2 = this, _info = Controller2.info(), _container = _info.container, _isDocument = _info.isDocument, _vertical = _info.vertical, _indicators = {
      groups: []
    };
    var log = function log2() {
      if (Controller2._log) {
        Array.prototype.splice.call(arguments, 1, 0, "(" + NAMESPACE + ")", "->");
        Controller2._log.apply(this, arguments);
      }
    };
    if (Controller2._indicators) {
      log(2, "WARNING: Scene already has a property '_indicators', which will be overwritten by plugin.");
    }
    this._indicators = _indicators;
    var handleBoundsPositionChange = function handleBoundsPositionChange2() {
      _indicators.updateBoundsPositions();
    };
    var handleTriggerPositionChange = function handleTriggerPositionChange2() {
      _indicators.updateTriggerGroupPositions();
    };
    _container.addEventListener("resize", handleTriggerPositionChange);
    if (!_isDocument) {
      window2.addEventListener("resize", handleTriggerPositionChange);
      window2.addEventListener("scroll", handleTriggerPositionChange);
    }
    _container.addEventListener("resize", handleBoundsPositionChange);
    _container.addEventListener("scroll", handleBoundsPositionChange);
    this._indicators.updateBoundsPositions = function(specificIndicator) {
      var groups = specificIndicator ? [_util.extend({}, specificIndicator.triggerGroup, {
        members: [specificIndicator]
      })] : _indicators.groups, g = groups.length, css = {}, paramPos = _vertical ? "left" : "top", paramDimension = _vertical ? "width" : "height", edge = _vertical ? _util.get.scrollLeft(_container) + _util.get.width(_container) - EDGE_OFFSET : _util.get.scrollTop(_container) + _util.get.height(_container) - EDGE_OFFSET, b, triggerSize, group;
      while (g--) {
        group = groups[g];
        b = group.members.length;
        triggerSize = _util.get[paramDimension](group.element.firstChild);
        while (b--) {
          css[paramPos] = edge - triggerSize;
          _util.css(group.members[b].bounds, css);
        }
      }
    };
    this._indicators.updateTriggerGroupPositions = function(specificGroup) {
      var groups = specificGroup ? [specificGroup] : _indicators.groups, i = groups.length, container = _isDocument ? document.body : _container, containerOffset = _isDocument ? {
        top: 0,
        left: 0
      } : _util.get.offset(container, true), edge = _vertical ? _util.get.width(_container) - EDGE_OFFSET : _util.get.height(_container) - EDGE_OFFSET, paramDimension = _vertical ? "width" : "height", paramTransform = _vertical ? "Y" : "X";
      var group, elem, pos, elemSize, transform;
      while (i--) {
        group = groups[i];
        elem = group.element;
        pos = group.triggerHook * Controller2.info("size");
        elemSize = _util.get[paramDimension](elem.firstChild.firstChild);
        transform = pos > elemSize ? "translate" + paramTransform + "(-100%)" : "";
        _util.css(elem, {
          top: containerOffset.top + (_vertical ? pos : edge - group.members[0].options.indent),
          left: containerOffset.left + (_vertical ? edge - group.members[0].options.indent : pos)
        });
        _util.css(elem.firstChild.firstChild, {
          "-ms-transform": transform,
          "-webkit-transform": transform,
          "transform": transform
        });
      }
    };
    this._indicators.updateTriggerGroupLabel = function(group) {
      var text = "trigger" + (group.members.length > 1 ? "" : " " + group.members[0].options.name), elem = group.element.firstChild.firstChild, doUpdate = elem.textContent !== text;
      if (doUpdate) {
        elem.textContent = text;
        if (_vertical) {
          _indicators.updateBoundsPositions();
        }
      }
    };
    this.addScene = function(newScene) {
      if (this._options.addIndicators && newScene instanceof ScrollMagic2.Scene && newScene.controller() === Controller2) {
        newScene.addIndicators();
      }
      this.$super.addScene.apply(this, arguments);
    };
    this.destroy = function() {
      _container.removeEventListener("resize", handleTriggerPositionChange);
      if (!_isDocument) {
        window2.removeEventListener("resize", handleTriggerPositionChange);
        window2.removeEventListener("scroll", handleTriggerPositionChange);
      }
      _container.removeEventListener("resize", handleBoundsPositionChange);
      _container.removeEventListener("scroll", handleBoundsPositionChange);
      this.$super.destroy.apply(this, arguments);
    };
    return Controller2;
  });
  var Indicator = function Indicator2(Scene3, options) {
    var Indicator3 = this, _elemBounds = TPL.bounds(), _elemStart = TPL.start(options.colorStart), _elemEnd = TPL.end(options.colorEnd), _boundsContainer = options.parent && _util.get.elements(options.parent)[0], _vertical, _ctrl;
    var log = function log2() {
      if (Scene3._log) {
        Array.prototype.splice.call(arguments, 1, 0, "(" + NAMESPACE + ")", "->");
        Scene3._log.apply(this, arguments);
      }
    };
    options.name = options.name || _autoindex;
    _elemStart.firstChild.textContent += " " + options.name;
    _elemEnd.textContent += " " + options.name;
    _elemBounds.appendChild(_elemStart);
    _elemBounds.appendChild(_elemEnd);
    Indicator3.options = options;
    Indicator3.bounds = _elemBounds;
    Indicator3.triggerGroup = void 0;
    this.add = function() {
      _ctrl = Scene3.controller();
      _vertical = _ctrl.info("vertical");
      var isDocument = _ctrl.info("isDocument");
      if (!_boundsContainer) {
        _boundsContainer = isDocument ? document.body : _ctrl.info("container");
      }
      if (!isDocument && _util.css(_boundsContainer, "position") === "static") {
        _util.css(_boundsContainer, {
          position: "relative"
        });
      }
      Scene3.on("change.plugin_addIndicators", handleTriggerParamsChange);
      Scene3.on("shift.plugin_addIndicators", handleBoundsParamsChange);
      updateTriggerGroup();
      updateBounds();
      setTimeout(function() {
        _ctrl._indicators.updateBoundsPositions(Indicator3);
      }, 0);
      log(3, "added indicators");
    };
    this.remove = function() {
      if (Indicator3.triggerGroup) {
        Scene3.off("change.plugin_addIndicators", handleTriggerParamsChange);
        Scene3.off("shift.plugin_addIndicators", handleBoundsParamsChange);
        if (Indicator3.triggerGroup.members.length > 1) {
          var group = Indicator3.triggerGroup;
          group.members.splice(group.members.indexOf(Indicator3), 1);
          _ctrl._indicators.updateTriggerGroupLabel(group);
          _ctrl._indicators.updateTriggerGroupPositions(group);
          Indicator3.triggerGroup = void 0;
        } else {
          removeTriggerGroup();
        }
        removeBounds();
        log(3, "removed indicators");
      }
    };
    var handleBoundsParamsChange = function handleBoundsParamsChange2() {
      updateBounds();
    };
    var handleTriggerParamsChange = function handleTriggerParamsChange2(e) {
      if (e.what === "triggerHook") {
        updateTriggerGroup();
      }
    };
    var addBounds = function addBounds2() {
      var v = _ctrl.info("vertical");
      _util.css(_elemStart.firstChild, {
        "border-bottom-width": v ? 1 : 0,
        "border-right-width": v ? 0 : 1,
        "bottom": v ? -1 : options.indent,
        "right": v ? options.indent : -1,
        "padding": v ? "0 8px" : "2px 4px"
      });
      _util.css(_elemEnd, {
        "border-top-width": v ? 1 : 0,
        "border-left-width": v ? 0 : 1,
        "top": v ? "100%" : "",
        "right": v ? options.indent : "",
        "bottom": v ? "" : options.indent,
        "left": v ? "" : "100%",
        "padding": v ? "0 8px" : "2px 4px"
      });
      _boundsContainer.appendChild(_elemBounds);
    };
    var removeBounds = function removeBounds2() {
      _elemBounds.parentNode.removeChild(_elemBounds);
    };
    var updateBounds = function updateBounds2() {
      if (_elemBounds.parentNode !== _boundsContainer) {
        addBounds();
      }
      var css = {};
      css[_vertical ? "top" : "left"] = Scene3.triggerPosition();
      css[_vertical ? "height" : "width"] = Scene3.duration();
      _util.css(_elemBounds, css);
      _util.css(_elemEnd, {
        display: Scene3.duration() > 0 ? "" : "none"
      });
    };
    var addTriggerGroup = function addTriggerGroup2() {
      var triggerElem = TPL.trigger(options.colorTrigger);
      var css = {};
      css[_vertical ? "right" : "bottom"] = 0;
      css[_vertical ? "border-top-width" : "border-left-width"] = 1;
      _util.css(triggerElem.firstChild, css);
      _util.css(triggerElem.firstChild.firstChild, {
        padding: _vertical ? "0 8px 3px 8px" : "3px 4px"
      });
      document.body.appendChild(triggerElem);
      var newGroup = {
        triggerHook: Scene3.triggerHook(),
        element: triggerElem,
        members: [Indicator3]
      };
      _ctrl._indicators.groups.push(newGroup);
      Indicator3.triggerGroup = newGroup;
      _ctrl._indicators.updateTriggerGroupLabel(newGroup);
      _ctrl._indicators.updateTriggerGroupPositions(newGroup);
    };
    var removeTriggerGroup = function removeTriggerGroup2() {
      _ctrl._indicators.groups.splice(_ctrl._indicators.groups.indexOf(Indicator3.triggerGroup), 1);
      Indicator3.triggerGroup.element.parentNode.removeChild(Indicator3.triggerGroup.element);
      Indicator3.triggerGroup = void 0;
    };
    var updateTriggerGroup = function updateTriggerGroup2() {
      var triggerHook = Scene3.triggerHook(), closeEnough = 1e-4;
      if (Indicator3.triggerGroup) {
        if (Math.abs(Indicator3.triggerGroup.triggerHook - triggerHook) < closeEnough) {
          return;
        }
      }
      var groups = _ctrl._indicators.groups, group, i = groups.length;
      while (i--) {
        group = groups[i];
        if (Math.abs(group.triggerHook - triggerHook) < closeEnough) {
          if (Indicator3.triggerGroup) {
            if (Indicator3.triggerGroup.members.length === 1) {
              removeTriggerGroup();
            } else {
              Indicator3.triggerGroup.members.splice(Indicator3.triggerGroup.members.indexOf(Indicator3), 1);
              _ctrl._indicators.updateTriggerGroupLabel(Indicator3.triggerGroup);
              _ctrl._indicators.updateTriggerGroupPositions(Indicator3.triggerGroup);
            }
          }
          group.members.push(Indicator3);
          Indicator3.triggerGroup = group;
          _ctrl._indicators.updateTriggerGroupLabel(group);
          return;
        }
      }
      if (Indicator3.triggerGroup) {
        if (Indicator3.triggerGroup.members.length === 1) {
          Indicator3.triggerGroup.triggerHook = triggerHook;
          _ctrl._indicators.updateTriggerGroupPositions(Indicator3.triggerGroup);
          return;
        } else {
          Indicator3.triggerGroup.members.splice(Indicator3.triggerGroup.members.indexOf(Indicator3), 1);
          _ctrl._indicators.updateTriggerGroupLabel(Indicator3.triggerGroup);
          _ctrl._indicators.updateTriggerGroupPositions(Indicator3.triggerGroup);
          Indicator3.triggerGroup = void 0;
        }
      }
      addTriggerGroup();
    };
  };
  var TPL = {
    start: function start(color) {
      var inner = document.createElement("div");
      inner.textContent = "start";
      _util.css(inner, {
        position: "absolute",
        overflow: "visible",
        "border-width": 0,
        "border-style": "solid",
        color,
        "border-color": color
      });
      var e = document.createElement("div");
      _util.css(e, {
        position: "absolute",
        overflow: "visible",
        width: 0,
        height: 0
      });
      e.appendChild(inner);
      return e;
    },
    end: function end(color) {
      var e = document.createElement("div");
      e.textContent = "end";
      _util.css(e, {
        position: "absolute",
        overflow: "visible",
        "border-width": 0,
        "border-style": "solid",
        color,
        "border-color": color
      });
      return e;
    },
    bounds: function bounds() {
      var e = document.createElement("div");
      _util.css(e, {
        position: "absolute",
        overflow: "visible",
        "white-space": "nowrap",
        "pointer-events": "none",
        "font-size": FONT_SIZE
      });
      e.style.zIndex = ZINDEX;
      return e;
    },
    trigger: function trigger(color) {
      var inner = document.createElement("div");
      inner.textContent = "trigger";
      _util.css(inner, {
        position: "relative"
      });
      var w = document.createElement("div");
      _util.css(w, {
        position: "absolute",
        overflow: "visible",
        "border-width": 0,
        "border-style": "solid",
        color,
        "border-color": color
      });
      w.appendChild(inner);
      var e = document.createElement("div");
      _util.css(e, {
        position: "fixed",
        overflow: "visible",
        "white-space": "nowrap",
        "pointer-events": "none",
        "font-size": FONT_SIZE
      });
      e.style.zIndex = ZINDEX;
      e.appendChild(w);
      return e;
    }
  };
}
debugAddIndicators(ScrollMagic);
var refOrInnerRef = function refOrInnerRef2(child) {
  if (child.type && child.type.$$typeof && child.type.$$typeof.toString() === "Symbol(react.forward_ref)") {
    return "ref";
  }
  if (child.type && child.type.styledComponentId) {
    return "innerRef";
  }
  return "ref";
};
var isGSAP = function isGSAP2(child) {
  if (import_react.default.Children.count(child) === 1 && child.type && (child.type.displayName === "Tween" || child.type.displayName === "Timeline")) {
    return true;
  }
  return false;
};
var controlGSAP = function controlGSAP2(child, progress, event) {
  if (isGSAP(child)) {
    var props = _extends({}, child.props, { totalProgress: progress, paused: true });
    return import_react.default.createElement(
      "div",
      null,
      import_react.default.createElement(child.type, props)
    );
  }
  return child;
};
var callChildFunction = function callChildFunction2(children, progress, event) {
  if (children && typeof children === "function") {
    return children(progress, event);
  }
  return children;
};
var getChild = function getChild2(children, progress, event) {
  children = controlGSAP(children, progress, event);
  children = callChildFunction(children, progress, event);
  return import_react.default.Children.only(children);
};
var isString = function isString2(element) {
  if (typeof element === "string" || element instanceof String) {
    return true;
  }
  return false;
};
var SceneBase = function(_React$PureComponent) {
  inherits(SceneBase2, _React$PureComponent);
  function SceneBase2() {
    var _ref;
    var _temp, _this, _ret;
    classCallCheck(this, SceneBase2);
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = SceneBase2.__proto__ || Object.getPrototypeOf(SceneBase2)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      event: "init",
      progress: 0
    }, _temp), possibleConstructorReturn(_this, _ret);
  }
  createClass(SceneBase2, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var _props = this.props, children = _props.children, controller = _props.controller, classToggle = _props.classToggle, pin = _props.pin, pinSettings = _props.pinSettings, indicators = _props.indicators, enabled = _props.enabled, sceneParams = objectWithoutProperties(_props, ["children", "controller", "classToggle", "pin", "pinSettings", "indicators", "enabled"]);
      var element = this.ref;
      sceneParams.triggerElement = sceneParams.triggerElement === null ? null : sceneParams.triggerElement || element;
      this.scene = new ScrollMagic.Scene(sceneParams);
      this.initEventHandlers();
      if (classToggle) {
        this.setClassToggle(this.scene, element, classToggle);
      }
      if (pin || pinSettings) {
        this.setPin(this.scene, element, pin, pinSettings);
      }
      if (indicators) {
        this.scene.addIndicators({ name: " " });
      }
      if (enabled !== void 0) {
        this.scene.enabled(enabled);
      }
      this.scene.addTo(controller);
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      var _props2 = this.props, duration = _props2.duration, offset = _props2.offset, triggerElement = _props2.triggerElement, triggerHook = _props2.triggerHook, reverse = _props2.reverse, enabled = _props2.enabled;
      if (duration !== void 0 && duration !== prevProps.duration) {
        this.scene.duration(duration);
      }
      if (offset !== void 0 && offset !== prevProps.offset) {
        this.scene.offset(offset);
      }
      if (triggerElement !== void 0 && triggerElement !== prevProps.triggerElement)
        ;
      if (triggerHook !== void 0 && triggerHook !== prevProps.triggerHook) {
        this.scene.triggerHook(triggerHook);
      }
      if (reverse !== void 0 && reverse !== prevProps.reverse) {
        this.scene.reverse(reverse);
      }
      if (enabled !== void 0 && enabled !== prevProps.enabled) {
        this.scene.enabled(enabled);
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.scene.destroy();
    }
  }, {
    key: "setClassToggle",
    value: function setClassToggle(scene, element, classToggle) {
      if (Array.isArray(classToggle) && classToggle.length === 2) {
        scene.setClassToggle(classToggle[0], classToggle[1]);
      } else {
        scene.setClassToggle(element, classToggle);
      }
    }
  }, {
    key: "setPin",
    value: function setPin(scene, element, pin, pinSettings) {
      element = isString(pin) ? pin : element;
      scene.setPin(element, pinSettings);
    }
  }, {
    key: "initEventHandlers",
    value: function initEventHandlers() {
      var _this2 = this;
      var _props3 = this.props, children = _props3.children, _props3$progressEvent = _props3.progressEvents, progressEvents = _props3$progressEvent === void 0 ? true : _props3$progressEvent;
      if (typeof children !== "function" && !isGSAP(callChildFunction(children, 0, "init"))) {
        return;
      }
      this.scene.on("start end enter leave", function(event) {
        _this2.setState({
          event
        });
      });
      if (progressEvents) {
        this.scene.on("progress", function(event) {
          _this2.setState({
            progress: event.progress
          });
        });
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this3 = this;
      var children = this.props.children;
      var _state = this.state, progress = _state.progress, event = _state.event;
      var child = getChild(children, progress, event);
      return import_react.default.cloneElement(child, defineProperty({}, refOrInnerRef(child), function(ref) {
        return _this3.ref = ref;
      }));
    }
  }]);
  return SceneBase2;
}(import_react.default.PureComponent);
var SceneWrapper = function(_React$PureComponent2) {
  inherits(SceneWrapper2, _React$PureComponent2);
  function SceneWrapper2() {
    classCallCheck(this, SceneWrapper2);
    return possibleConstructorReturn(this, (SceneWrapper2.__proto__ || Object.getPrototypeOf(SceneWrapper2)).apply(this, arguments));
  }
  createClass(SceneWrapper2, [{
    key: "render",
    value: function render() {
      if (!this.props.controller) {
        var _children = this.props.children;
        var _progress = 0;
        var _event = "init";
        return getChild(_children, _progress, _event);
      }
      return import_react.default.createElement(SceneBase, this.props);
    }
  }]);
  return SceneWrapper2;
}(import_react.default.PureComponent);
SceneWrapper.displayName = "Scene";
var Scene = function Scene2(_ref2) {
  var children = _ref2.children, props = objectWithoutProperties(_ref2, ["children"]);
  return import_react.default.createElement(
    ControllerContext.Consumer,
    null,
    function(controller) {
      return import_react.default.createElement(
        SceneWrapper,
        _extends({ controller }, props),
        children
      );
    }
  );
};
export {
  Controller,
  Scene
};
/*!
 * ScrollMagic v2.0.7 (2019-05-07)
 * The javascript library for magical scroll interactions.
 * (c) 2019 Jan Paepke (@janpaepke)
 * Project Website: http://scrollmagic.io
 * 
 * @version 2.0.7
 * @license Dual licensed under MIT license and GPL.
 * @author Jan Paepke - e-mail@janpaepke.de
 *
 * @file Debug Extension for ScrollMagic.
 */
/*!
 * ScrollMagic v2.0.7 (2019-05-07)
 * The javascript library for magical scroll interactions.
 * (c) 2019 Jan Paepke (@janpaepke)
 * Project Website: http://scrollmagic.io
 * 
 * @version 2.0.7
 * @license Dual licensed under MIT license and GPL.
 * @author Jan Paepke - e-mail@janpaepke.de
 *
 * @file ScrollMagic main library.
 */
//# sourceMappingURL=react-scrollmagic.js.map
