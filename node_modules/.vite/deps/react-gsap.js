import {
  require_react_is
} from "./chunk-U64MNBTI.js";
import {
  gsapWithCSS
} from "./chunk-LVEBC4HE.js";
import {
  require_react
} from "./chunk-X6MODOAL.js";
import {
  __commonJS,
  __toESM
} from "./chunk-J43GMYXM.js";

// node_modules/gsap/dist/ScrollTrigger.js
var require_ScrollTrigger = __commonJS({
  "node_modules/gsap/dist/ScrollTrigger.js"(exports, module) {
    (function(global, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global = global || self, factory(global.window = global.window || {}));
    })(exports, function(exports2) {
      "use strict";
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      var gsap2, _coreInitted, _clamp, _win, _doc, _docEl, _body, _isTouch, _pointerType, ScrollTrigger2, _root, _normalizer, _eventTypes, _getGSAP4 = function _getGSAP5() {
        return gsap2 || typeof window !== "undefined" && (gsap2 = window.gsap) && gsap2.registerPlugin && gsap2;
      }, _startup = 1, _observers = [], _scrollers = [], _proxies = [], _getTime = Date.now, _bridge = function _bridge2(name, value) {
        return value;
      }, _integrate = function _integrate2() {
        var core = ScrollTrigger2.core, data = core.bridge || {}, scrollers = core._scrollers, proxies = core._proxies;
        scrollers.push.apply(scrollers, _scrollers);
        proxies.push.apply(proxies, _proxies);
        _scrollers = scrollers;
        _proxies = proxies;
        _bridge = function _bridge2(name, value) {
          return data[name](value);
        };
      }, _getProxyProp = function _getProxyProp2(element, property) {
        return ~_proxies.indexOf(element) && _proxies[_proxies.indexOf(element) + 1][property];
      }, _isViewport = function _isViewport2(el) {
        return !!~_root.indexOf(el);
      }, _addListener = function _addListener2(element, type, func, nonPassive, capture) {
        return element.addEventListener(type, func, {
          passive: !nonPassive,
          capture: !!capture
        });
      }, _removeListener = function _removeListener2(element, type, func, capture) {
        return element.removeEventListener(type, func, !!capture);
      }, _scrollLeft = "scrollLeft", _scrollTop = "scrollTop", _onScroll = function _onScroll2() {
        return _normalizer && _normalizer.isPressed || _scrollers.cache++;
      }, _scrollCacheFunc = function _scrollCacheFunc2(f, doNotCache) {
        var cachingFunc = function cachingFunc2(value) {
          if (value || value === 0) {
            _startup && (_win.history.scrollRestoration = "manual");
            var isNormalizing = _normalizer && _normalizer.isPressed;
            value = cachingFunc2.v = Math.round(value) || (_normalizer && _normalizer.iOS ? 1 : 0);
            f(value);
            cachingFunc2.cacheID = _scrollers.cache;
            isNormalizing && _bridge("ss", value);
          } else if (doNotCache || _scrollers.cache !== cachingFunc2.cacheID || _bridge("ref")) {
            cachingFunc2.cacheID = _scrollers.cache;
            cachingFunc2.v = f();
          }
          return cachingFunc2.v + cachingFunc2.offset;
        };
        cachingFunc.offset = 0;
        return f && cachingFunc;
      }, _horizontal = {
        s: _scrollLeft,
        p: "left",
        p2: "Left",
        os: "right",
        os2: "Right",
        d: "width",
        d2: "Width",
        a: "x",
        sc: _scrollCacheFunc(function(value) {
          return arguments.length ? _win.scrollTo(value, _vertical.sc()) : _win.pageXOffset || _doc[_scrollLeft] || _docEl[_scrollLeft] || _body[_scrollLeft] || 0;
        })
      }, _vertical = {
        s: _scrollTop,
        p: "top",
        p2: "Top",
        os: "bottom",
        os2: "Bottom",
        d: "height",
        d2: "Height",
        a: "y",
        op: _horizontal,
        sc: _scrollCacheFunc(function(value) {
          return arguments.length ? _win.scrollTo(_horizontal.sc(), value) : _win.pageYOffset || _doc[_scrollTop] || _docEl[_scrollTop] || _body[_scrollTop] || 0;
        })
      }, _getTarget = function _getTarget2(t) {
        return gsap2.utils.toArray(t)[0] || (typeof t === "string" && gsap2.config().nullTargetWarn !== false ? console.warn("Element not found:", t) : null);
      }, _getScrollFunc = function _getScrollFunc2(element, _ref) {
        var s = _ref.s, sc = _ref.sc;
        var i = _scrollers.indexOf(element), offset = sc === _vertical.sc ? 1 : 2;
        !~i && (i = _scrollers.push(element) - 1);
        return _scrollers[i + offset] || (_scrollers[i + offset] = _scrollCacheFunc(_getProxyProp(element, s), true) || (_isViewport(element) ? sc : _scrollCacheFunc(function(value) {
          return arguments.length ? element[s] = value : element[s];
        })));
      }, _getVelocityProp = function _getVelocityProp2(value, minTimeRefresh, useDelta) {
        var v1 = value, v2 = value, t1 = _getTime(), t2 = t1, min = minTimeRefresh || 50, dropToZeroTime = Math.max(500, min * 3), update = function update2(value2, force) {
          var t = _getTime();
          if (force || t - t1 > min) {
            v2 = v1;
            v1 = value2;
            t2 = t1;
            t1 = t;
          } else if (useDelta) {
            v1 += value2;
          } else {
            v1 = v2 + (value2 - v2) / (t - t2) * (t1 - t2);
          }
        }, reset = function reset2() {
          v2 = v1 = useDelta ? 0 : v1;
          t2 = t1 = 0;
        }, getVelocity = function getVelocity2(latestValue) {
          var tOld = t2, vOld = v2, t = _getTime();
          (latestValue || latestValue === 0) && latestValue !== v1 && update(latestValue);
          return t1 === t2 || t - t2 > dropToZeroTime ? 0 : (v1 + (useDelta ? vOld : -vOld)) / ((useDelta ? t : t1) - tOld) * 1e3;
        };
        return {
          update,
          reset,
          getVelocity
        };
      }, _getEvent = function _getEvent2(e, preventDefault) {
        preventDefault && !e._gsapAllow && e.preventDefault();
        return e.changedTouches ? e.changedTouches[0] : e;
      }, _getAbsoluteMax = function _getAbsoluteMax2(a) {
        var max = Math.max.apply(Math, a), min = Math.min.apply(Math, a);
        return Math.abs(max) >= Math.abs(min) ? max : min;
      }, _setScrollTrigger = function _setScrollTrigger2() {
        ScrollTrigger2 = gsap2.core.globals().ScrollTrigger;
        ScrollTrigger2 && ScrollTrigger2.core && _integrate();
      }, _initCore = function _initCore2(core) {
        gsap2 = core || _getGSAP4();
        if (gsap2 && typeof document !== "undefined" && document.body) {
          _win = window;
          _doc = document;
          _docEl = _doc.documentElement;
          _body = _doc.body;
          _root = [_win, _doc, _docEl, _body];
          _clamp = gsap2.utils.clamp;
          _pointerType = "onpointerenter" in _body ? "pointer" : "mouse";
          _isTouch = Observer.isTouch = _win.matchMedia && _win.matchMedia("(hover: none), (pointer: coarse)").matches ? 1 : "ontouchstart" in _win || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0 ? 2 : 0;
          _eventTypes = Observer.eventTypes = ("ontouchstart" in _docEl ? "touchstart,touchmove,touchcancel,touchend" : !("onpointerdown" in _docEl) ? "mousedown,mousemove,mouseup,mouseup" : "pointerdown,pointermove,pointercancel,pointerup").split(",");
          setTimeout(function() {
            return _startup = 0;
          }, 500);
          _setScrollTrigger();
          _coreInitted = 1;
        }
        return _coreInitted;
      };
      _horizontal.op = _vertical;
      _scrollers.cache = 0;
      var Observer = function() {
        function Observer2(vars) {
          this.init(vars);
        }
        var _proto = Observer2.prototype;
        _proto.init = function init3(vars) {
          _coreInitted || _initCore(gsap2) || console.warn("Please gsap.registerPlugin(Observer)");
          ScrollTrigger2 || _setScrollTrigger();
          var tolerance = vars.tolerance, dragMinimum = vars.dragMinimum, type = vars.type, target = vars.target, lineHeight = vars.lineHeight, debounce = vars.debounce, preventDefault = vars.preventDefault, onStop = vars.onStop, onStopDelay = vars.onStopDelay, ignore = vars.ignore, wheelSpeed = vars.wheelSpeed, event = vars.event, onDragStart = vars.onDragStart, onDragEnd = vars.onDragEnd, onDrag = vars.onDrag, onPress = vars.onPress, onRelease = vars.onRelease, onRight = vars.onRight, onLeft = vars.onLeft, onUp = vars.onUp, onDown = vars.onDown, onChangeX = vars.onChangeX, onChangeY = vars.onChangeY, onChange = vars.onChange, onToggleX = vars.onToggleX, onToggleY = vars.onToggleY, onHover = vars.onHover, onHoverEnd = vars.onHoverEnd, onMove = vars.onMove, ignoreCheck = vars.ignoreCheck, isNormalizer = vars.isNormalizer, onGestureStart = vars.onGestureStart, onGestureEnd = vars.onGestureEnd, onWheel = vars.onWheel, onEnable = vars.onEnable, onDisable = vars.onDisable, onClick = vars.onClick, scrollSpeed = vars.scrollSpeed, capture = vars.capture, allowClicks = vars.allowClicks, lockAxis = vars.lockAxis, onLockAxis = vars.onLockAxis;
          this.target = target = _getTarget(target) || _docEl;
          this.vars = vars;
          ignore && (ignore = gsap2.utils.toArray(ignore));
          tolerance = tolerance || 0;
          dragMinimum = dragMinimum || 0;
          wheelSpeed = wheelSpeed || 1;
          scrollSpeed = scrollSpeed || 1;
          type = type || "wheel,touch,pointer";
          debounce = debounce !== false;
          lineHeight || (lineHeight = parseFloat(_win.getComputedStyle(_body).lineHeight) || 22);
          var id, onStopDelayedCall, dragged, moved, wheeled, locked, axis, self2 = this, prevDeltaX = 0, prevDeltaY = 0, scrollFuncX = _getScrollFunc(target, _horizontal), scrollFuncY = _getScrollFunc(target, _vertical), scrollX = scrollFuncX(), scrollY = scrollFuncY(), limitToTouch = ~type.indexOf("touch") && !~type.indexOf("pointer") && _eventTypes[0] === "pointerdown", isViewport = _isViewport(target), ownerDoc = target.ownerDocument || _doc, deltaX = [0, 0, 0], deltaY = [0, 0, 0], onClickTime = 0, clickCapture = function clickCapture2() {
            return onClickTime = _getTime();
          }, _ignoreCheck = function _ignoreCheck2(e, isPointerOrTouch) {
            return (self2.event = e) && ignore && ~ignore.indexOf(e.target) || isPointerOrTouch && limitToTouch && e.pointerType !== "touch" || ignoreCheck && ignoreCheck(e, isPointerOrTouch);
          }, onStopFunc = function onStopFunc2() {
            self2._vx.reset();
            self2._vy.reset();
            onStopDelayedCall.pause();
            onStop && onStop(self2);
          }, update = function update2() {
            var dx = self2.deltaX = _getAbsoluteMax(deltaX), dy = self2.deltaY = _getAbsoluteMax(deltaY), changedX = Math.abs(dx) >= tolerance, changedY = Math.abs(dy) >= tolerance;
            onChange && (changedX || changedY) && onChange(self2, dx, dy, deltaX, deltaY);
            if (changedX) {
              onRight && self2.deltaX > 0 && onRight(self2);
              onLeft && self2.deltaX < 0 && onLeft(self2);
              onChangeX && onChangeX(self2);
              onToggleX && self2.deltaX < 0 !== prevDeltaX < 0 && onToggleX(self2);
              prevDeltaX = self2.deltaX;
              deltaX[0] = deltaX[1] = deltaX[2] = 0;
            }
            if (changedY) {
              onDown && self2.deltaY > 0 && onDown(self2);
              onUp && self2.deltaY < 0 && onUp(self2);
              onChangeY && onChangeY(self2);
              onToggleY && self2.deltaY < 0 !== prevDeltaY < 0 && onToggleY(self2);
              prevDeltaY = self2.deltaY;
              deltaY[0] = deltaY[1] = deltaY[2] = 0;
            }
            if (moved || dragged) {
              onMove && onMove(self2);
              onLockAxis && locked && onLockAxis(self2);
              if (dragged) {
                onDrag(self2);
                dragged = false;
              }
              moved = locked = false;
            }
            if (wheeled) {
              onWheel(self2);
              wheeled = false;
            }
            id = 0;
          }, onDelta = function onDelta2(x, y, index) {
            deltaX[index] += x;
            deltaY[index] += y;
            self2._vx.update(x);
            self2._vy.update(y);
            debounce ? id || (id = requestAnimationFrame(update)) : update();
          }, onTouchOrPointerDelta = function onTouchOrPointerDelta2(x, y) {
            if (axis !== "y") {
              deltaX[2] += x;
              self2._vx.update(x, true);
            }
            if (axis !== "x") {
              deltaY[2] += y;
              self2._vy.update(y, true);
            }
            if (lockAxis && !axis) {
              self2.axis = axis = Math.abs(x) > Math.abs(y) ? "x" : "y";
              locked = true;
            }
            debounce ? id || (id = requestAnimationFrame(update)) : update();
          }, _onDrag = function _onDrag2(e) {
            if (_ignoreCheck(e, 1)) {
              return;
            }
            e = _getEvent(e, preventDefault);
            var x = e.clientX, y = e.clientY, dx = x - self2.x, dy = y - self2.y, isDragging = self2.isDragging;
            self2.x = x;
            self2.y = y;
            if (isDragging || Math.abs(self2.startX - x) >= dragMinimum || Math.abs(self2.startY - y) >= dragMinimum) {
              onDrag && (dragged = true);
              isDragging || (self2.isDragging = true);
              onTouchOrPointerDelta(dx, dy);
              isDragging || onDragStart && onDragStart(self2);
            }
          }, _onPress = self2.onPress = function(e) {
            if (_ignoreCheck(e, 1)) {
              return;
            }
            self2.axis = axis = null;
            onStopDelayedCall.pause();
            self2.isPressed = true;
            e = _getEvent(e);
            prevDeltaX = prevDeltaY = 0;
            self2.startX = self2.x = e.clientX;
            self2.startY = self2.y = e.clientY;
            self2._vx.reset();
            self2._vy.reset();
            _addListener(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, preventDefault, true);
            self2.deltaX = self2.deltaY = 0;
            onPress && onPress(self2);
          }, _onRelease = function _onRelease2(e) {
            if (_ignoreCheck(e, 1)) {
              return;
            }
            _removeListener(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, true);
            var wasDragging = self2.isDragging && (Math.abs(self2.x - self2.startX) > 3 || Math.abs(self2.y - self2.startY) > 3), eventData = _getEvent(e);
            if (!wasDragging) {
              self2._vx.reset();
              self2._vy.reset();
              if (preventDefault && allowClicks) {
                gsap2.delayedCall(0.08, function() {
                  if (_getTime() - onClickTime > 300 && !e.defaultPrevented) {
                    if (e.target.click) {
                      e.target.click();
                    } else if (ownerDoc.createEvent) {
                      var syntheticEvent = ownerDoc.createEvent("MouseEvents");
                      syntheticEvent.initMouseEvent("click", true, true, _win, 1, eventData.screenX, eventData.screenY, eventData.clientX, eventData.clientY, false, false, false, false, 0, null);
                      e.target.dispatchEvent(syntheticEvent);
                    }
                  }
                });
              }
            }
            self2.isDragging = self2.isGesturing = self2.isPressed = false;
            onStop && !isNormalizer && onStopDelayedCall.restart(true);
            onDragEnd && wasDragging && onDragEnd(self2);
            onRelease && onRelease(self2, wasDragging);
          }, _onGestureStart = function _onGestureStart2(e) {
            return e.touches && e.touches.length > 1 && (self2.isGesturing = true) && onGestureStart(e, self2.isDragging);
          }, _onGestureEnd = function _onGestureEnd2() {
            return (self2.isGesturing = false) || onGestureEnd(self2);
          }, onScroll = function onScroll2(e) {
            if (_ignoreCheck(e)) {
              return;
            }
            var x = scrollFuncX(), y = scrollFuncY();
            onDelta((x - scrollX) * scrollSpeed, (y - scrollY) * scrollSpeed, 1);
            scrollX = x;
            scrollY = y;
            onStop && onStopDelayedCall.restart(true);
          }, _onWheel = function _onWheel2(e) {
            if (_ignoreCheck(e)) {
              return;
            }
            e = _getEvent(e, preventDefault);
            onWheel && (wheeled = true);
            var multiplier = (e.deltaMode === 1 ? lineHeight : e.deltaMode === 2 ? _win.innerHeight : 1) * wheelSpeed;
            onDelta(e.deltaX * multiplier, e.deltaY * multiplier, 0);
            onStop && !isNormalizer && onStopDelayedCall.restart(true);
          }, _onMove = function _onMove2(e) {
            if (_ignoreCheck(e)) {
              return;
            }
            var x = e.clientX, y = e.clientY, dx = x - self2.x, dy = y - self2.y;
            self2.x = x;
            self2.y = y;
            moved = true;
            (dx || dy) && onTouchOrPointerDelta(dx, dy);
          }, _onHover = function _onHover2(e) {
            self2.event = e;
            onHover(self2);
          }, _onHoverEnd = function _onHoverEnd2(e) {
            self2.event = e;
            onHoverEnd(self2);
          }, _onClick = function _onClick2(e) {
            return _ignoreCheck(e) || _getEvent(e, preventDefault) && onClick(self2);
          };
          onStopDelayedCall = self2._dc = gsap2.delayedCall(onStopDelay || 0.25, onStopFunc).pause();
          self2.deltaX = self2.deltaY = 0;
          self2._vx = _getVelocityProp(0, 50, true);
          self2._vy = _getVelocityProp(0, 50, true);
          self2.scrollX = scrollFuncX;
          self2.scrollY = scrollFuncY;
          self2.isDragging = self2.isGesturing = self2.isPressed = false;
          self2.enable = function(e) {
            if (!self2.isEnabled) {
              _addListener(isViewport ? ownerDoc : target, "scroll", _onScroll);
              type.indexOf("scroll") >= 0 && _addListener(isViewport ? ownerDoc : target, "scroll", onScroll, preventDefault, capture);
              type.indexOf("wheel") >= 0 && _addListener(target, "wheel", _onWheel, preventDefault, capture);
              if (type.indexOf("touch") >= 0 && _isTouch || type.indexOf("pointer") >= 0) {
                _addListener(target, _eventTypes[0], _onPress, preventDefault, capture);
                _addListener(ownerDoc, _eventTypes[2], _onRelease);
                _addListener(ownerDoc, _eventTypes[3], _onRelease);
                allowClicks && _addListener(target, "click", clickCapture, false, true);
                onClick && _addListener(target, "click", _onClick);
                onGestureStart && _addListener(ownerDoc, "gesturestart", _onGestureStart);
                onGestureEnd && _addListener(ownerDoc, "gestureend", _onGestureEnd);
                onHover && _addListener(target, _pointerType + "enter", _onHover);
                onHoverEnd && _addListener(target, _pointerType + "leave", _onHoverEnd);
                onMove && _addListener(target, _pointerType + "move", _onMove);
              }
              self2.isEnabled = true;
              e && e.type && _onPress(e);
              onEnable && onEnable(self2);
            }
            return self2;
          };
          self2.disable = function() {
            if (self2.isEnabled) {
              _observers.filter(function(o) {
                return o !== self2 && _isViewport(o.target);
              }).length || _removeListener(isViewport ? ownerDoc : target, "scroll", _onScroll);
              if (self2.isPressed) {
                self2._vx.reset();
                self2._vy.reset();
                _removeListener(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, true);
              }
              _removeListener(isViewport ? ownerDoc : target, "scroll", onScroll, capture);
              _removeListener(target, "wheel", _onWheel, capture);
              _removeListener(target, _eventTypes[0], _onPress, capture);
              _removeListener(ownerDoc, _eventTypes[2], _onRelease);
              _removeListener(ownerDoc, _eventTypes[3], _onRelease);
              _removeListener(target, "click", clickCapture, true);
              _removeListener(target, "click", _onClick);
              _removeListener(ownerDoc, "gesturestart", _onGestureStart);
              _removeListener(ownerDoc, "gestureend", _onGestureEnd);
              _removeListener(target, _pointerType + "enter", _onHover);
              _removeListener(target, _pointerType + "leave", _onHoverEnd);
              _removeListener(target, _pointerType + "move", _onMove);
              self2.isEnabled = self2.isPressed = self2.isDragging = false;
              onDisable && onDisable(self2);
            }
          };
          self2.kill = function() {
            self2.disable();
            var i = _observers.indexOf(self2);
            i >= 0 && _observers.splice(i, 1);
            _normalizer === self2 && (_normalizer = 0);
          };
          _observers.push(self2);
          isNormalizer && _isViewport(target) && (_normalizer = self2);
          self2.enable(event);
        };
        _createClass(Observer2, [{
          key: "velocityX",
          get: function get() {
            return this._vx.getVelocity();
          }
        }, {
          key: "velocityY",
          get: function get() {
            return this._vy.getVelocity();
          }
        }]);
        return Observer2;
      }();
      Observer.version = "3.10.4";
      Observer.create = function(vars) {
        return new Observer(vars);
      };
      Observer.register = _initCore;
      Observer.getAll = function() {
        return _observers.slice();
      };
      Observer.getById = function(id) {
        return _observers.filter(function(o) {
          return o.vars.id === id;
        })[0];
      };
      _getGSAP4() && gsap2.registerPlugin(Observer);
      var gsap$12, _coreInitted$1, _win$1, _doc$1, _docEl$1, _body$1, _root$1, _resizeDelay, _toArray, _clamp$1, _time2, _syncInterval, _refreshing, _pointerIsDown, _transformProp, _i, _prevWidth, _prevHeight, _autoRefresh, _sort, _suppressOverwrites, _ignoreResize, _normalizer$1, _ignoreMobileResize, _baseScreenHeight, _baseScreenWidth, _fixIOSBug, _limitCallbacks, _startup$1 = 1, _getTime$1 = Date.now, _time1 = _getTime$1(), _lastScrollTime = 0, _enabled = 0, _pointerDownHandler = function _pointerDownHandler2() {
        return _pointerIsDown = 1;
      }, _pointerUpHandler = function _pointerUpHandler2() {
        return _pointerIsDown = 0;
      }, _passThrough = function _passThrough2(v) {
        return v;
      }, _round = function _round2(value) {
        return Math.round(value * 1e5) / 1e5 || 0;
      }, _windowExists = function _windowExists2() {
        return typeof window !== "undefined";
      }, _getGSAP$12 = function _getGSAP5() {
        return gsap$12 || _windowExists() && (gsap$12 = window.gsap) && gsap$12.registerPlugin && gsap$12;
      }, _isViewport$1 = function _isViewport2(e) {
        return !!~_root$1.indexOf(e);
      }, _getBoundsFunc = function _getBoundsFunc2(element) {
        return _getProxyProp(element, "getBoundingClientRect") || (_isViewport$1(element) ? function() {
          _winOffsets.width = _win$1.innerWidth;
          _winOffsets.height = _win$1.innerHeight;
          return _winOffsets;
        } : function() {
          return _getBounds(element);
        });
      }, _getSizeFunc = function _getSizeFunc2(scroller, isViewport, _ref) {
        var d = _ref.d, d2 = _ref.d2, a = _ref.a;
        return (a = _getProxyProp(scroller, "getBoundingClientRect")) ? function() {
          return a()[d];
        } : function() {
          return (isViewport ? _win$1["inner" + d2] : scroller["client" + d2]) || 0;
        };
      }, _getOffsetsFunc = function _getOffsetsFunc2(element, isViewport) {
        return !isViewport || ~_proxies.indexOf(element) ? _getBoundsFunc(element) : function() {
          return _winOffsets;
        };
      }, _maxScroll = function _maxScroll2(element, _ref2) {
        var s = _ref2.s, d2 = _ref2.d2, d = _ref2.d, a = _ref2.a;
        return (s = "scroll" + d2) && (a = _getProxyProp(element, s)) ? a() - _getBoundsFunc(element)()[d] : _isViewport$1(element) ? (_docEl$1[s] || _body$1[s]) - (_win$1["inner" + d2] || _docEl$1["client" + d2] || _body$1["client" + d2]) : element[s] - element["offset" + d2];
      }, _iterateAutoRefresh = function _iterateAutoRefresh2(func, events) {
        for (var i = 0; i < _autoRefresh.length; i += 3) {
          (!events || ~events.indexOf(_autoRefresh[i + 1])) && func(_autoRefresh[i], _autoRefresh[i + 1], _autoRefresh[i + 2]);
        }
      }, _isString = function _isString2(value) {
        return typeof value === "string";
      }, _isFunction = function _isFunction2(value) {
        return typeof value === "function";
      }, _isNumber = function _isNumber2(value) {
        return typeof value === "number";
      }, _isObject = function _isObject2(value) {
        return typeof value === "object";
      }, _callIfFunc = function _callIfFunc2(value) {
        return _isFunction(value) && value();
      }, _combineFunc = function _combineFunc2(f1, f2) {
        return function() {
          var result1 = _callIfFunc(f1), result2 = _callIfFunc(f2);
          return function() {
            _callIfFunc(result1);
            _callIfFunc(result2);
          };
        };
      }, _endAnimation = function _endAnimation2(animation, reversed, pause) {
        return animation && animation.progress(reversed ? 0 : 1) && pause && animation.pause();
      }, _callback = function _callback2(self2, func) {
        if (self2.enabled) {
          var result = func(self2);
          result && result.totalTime && (self2.callbackAnimation = result);
        }
      }, _abs = Math.abs, _left = "left", _top = "top", _right = "right", _bottom = "bottom", _width = "width", _height = "height", _Right = "Right", _Left = "Left", _Top = "Top", _Bottom = "Bottom", _padding = "padding", _margin = "margin", _Width = "Width", _Height = "Height", _px = "px", _getComputedStyle = function _getComputedStyle2(element) {
        return _win$1.getComputedStyle(element);
      }, _makePositionable = function _makePositionable2(element) {
        var position = _getComputedStyle(element).position;
        element.style.position = position === "absolute" || position === "fixed" ? position : "relative";
      }, _setDefaults = function _setDefaults2(obj, defaults) {
        for (var p in defaults) {
          p in obj || (obj[p] = defaults[p]);
        }
        return obj;
      }, _getBounds = function _getBounds2(element, withoutTransforms) {
        var tween = withoutTransforms && _getComputedStyle(element)[_transformProp] !== "matrix(1, 0, 0, 1, 0, 0)" && gsap$12.to(element, {
          x: 0,
          y: 0,
          xPercent: 0,
          yPercent: 0,
          rotation: 0,
          rotationX: 0,
          rotationY: 0,
          scale: 1,
          skewX: 0,
          skewY: 0
        }).progress(1), bounds = element.getBoundingClientRect();
        tween && tween.progress(0).kill();
        return bounds;
      }, _getSize = function _getSize2(element, _ref3) {
        var d2 = _ref3.d2;
        return element["offset" + d2] || element["client" + d2] || 0;
      }, _getLabelRatioArray = function _getLabelRatioArray2(timeline) {
        var a = [], labels = timeline.labels, duration = timeline.duration(), p;
        for (p in labels) {
          a.push(labels[p] / duration);
        }
        return a;
      }, _getClosestLabel = function _getClosestLabel2(animation) {
        return function(value) {
          return gsap$12.utils.snap(_getLabelRatioArray(animation), value);
        };
      }, _snapDirectional = function _snapDirectional2(snapIncrementOrArray) {
        var snap = gsap$12.utils.snap(snapIncrementOrArray), a = Array.isArray(snapIncrementOrArray) && snapIncrementOrArray.slice(0).sort(function(a2, b) {
          return a2 - b;
        });
        return a ? function(value, direction, threshold) {
          if (threshold === void 0) {
            threshold = 1e-3;
          }
          var i;
          if (!direction) {
            return snap(value);
          }
          if (direction > 0) {
            value -= threshold;
            for (i = 0; i < a.length; i++) {
              if (a[i] >= value) {
                return a[i];
              }
            }
            return a[i - 1];
          } else {
            i = a.length;
            value += threshold;
            while (i--) {
              if (a[i] <= value) {
                return a[i];
              }
            }
          }
          return a[0];
        } : function(value, direction, threshold) {
          if (threshold === void 0) {
            threshold = 1e-3;
          }
          var snapped = snap(value);
          return !direction || Math.abs(snapped - value) < threshold || snapped - value < 0 === direction < 0 ? snapped : snap(direction < 0 ? value - snapIncrementOrArray : value + snapIncrementOrArray);
        };
      }, _getLabelAtDirection = function _getLabelAtDirection2(timeline) {
        return function(value, st) {
          return _snapDirectional(_getLabelRatioArray(timeline))(value, st.direction);
        };
      }, _multiListener = function _multiListener2(func, element, types, callback) {
        return types.split(",").forEach(function(type) {
          return func(element, type, callback);
        });
      }, _addListener$1 = function _addListener2(element, type, func, nonPassive, capture) {
        return element.addEventListener(type, func, {
          passive: !nonPassive,
          capture: !!capture
        });
      }, _removeListener$1 = function _removeListener2(element, type, func, capture) {
        return element.removeEventListener(type, func, !!capture);
      }, _wheelListener = function _wheelListener2(func, el, scrollFunc) {
        return scrollFunc && scrollFunc.wheelHandler && func(el, "wheel", scrollFunc);
      }, _markerDefaults = {
        startColor: "green",
        endColor: "red",
        indent: 0,
        fontSize: "16px",
        fontWeight: "normal"
      }, _defaults = {
        toggleActions: "play",
        anticipatePin: 0
      }, _keywords = {
        top: 0,
        left: 0,
        center: 0.5,
        bottom: 1,
        right: 1
      }, _offsetToPx = function _offsetToPx2(value, size) {
        if (_isString(value)) {
          var eqIndex = value.indexOf("="), relative = ~eqIndex ? +(value.charAt(eqIndex - 1) + 1) * parseFloat(value.substr(eqIndex + 1)) : 0;
          if (~eqIndex) {
            value.indexOf("%") > eqIndex && (relative *= size / 100);
            value = value.substr(0, eqIndex - 1);
          }
          value = relative + (value in _keywords ? _keywords[value] * size : ~value.indexOf("%") ? parseFloat(value) * size / 100 : parseFloat(value) || 0);
        }
        return value;
      }, _createMarker = function _createMarker2(type, name, container, direction, _ref4, offset, matchWidthEl, containerAnimation) {
        var startColor = _ref4.startColor, endColor = _ref4.endColor, fontSize = _ref4.fontSize, indent = _ref4.indent, fontWeight = _ref4.fontWeight;
        var e = _doc$1.createElement("div"), useFixedPosition = _isViewport$1(container) || _getProxyProp(container, "pinType") === "fixed", isScroller = type.indexOf("scroller") !== -1, parent = useFixedPosition ? _body$1 : container, isStart = type.indexOf("start") !== -1, color = isStart ? startColor : endColor, css = "border-color:" + color + ";font-size:" + fontSize + ";color:" + color + ";font-weight:" + fontWeight + ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;";
        css += "position:" + ((isScroller || containerAnimation) && useFixedPosition ? "fixed;" : "absolute;");
        (isScroller || containerAnimation || !useFixedPosition) && (css += (direction === _vertical ? _right : _bottom) + ":" + (offset + parseFloat(indent)) + "px;");
        matchWidthEl && (css += "box-sizing:border-box;text-align:left;width:" + matchWidthEl.offsetWidth + "px;");
        e._isStart = isStart;
        e.setAttribute("class", "gsap-marker-" + type + (name ? " marker-" + name : ""));
        e.style.cssText = css;
        e.innerText = name || name === 0 ? type + "-" + name : type;
        parent.children[0] ? parent.insertBefore(e, parent.children[0]) : parent.appendChild(e);
        e._offset = e["offset" + direction.op.d2];
        _positionMarker(e, 0, direction, isStart);
        return e;
      }, _positionMarker = function _positionMarker2(marker, start, direction, flipped) {
        var vars = {
          display: "block"
        }, side = direction[flipped ? "os2" : "p2"], oppositeSide = direction[flipped ? "p2" : "os2"];
        marker._isFlipped = flipped;
        vars[direction.a + "Percent"] = flipped ? -100 : 0;
        vars[direction.a] = flipped ? "1px" : 0;
        vars["border" + side + _Width] = 1;
        vars["border" + oppositeSide + _Width] = 0;
        vars[direction.p] = start + "px";
        gsap$12.set(marker, vars);
      }, _triggers = [], _ids = {}, _rafID, _sync = function _sync2() {
        return _getTime$1() - _lastScrollTime > 34 && _updateAll();
      }, _onScroll$1 = function _onScroll2() {
        if (!_normalizer$1 || !_normalizer$1.isPressed || _normalizer$1.startX > _body$1.clientWidth) {
          _scrollers.cache++;
          _rafID || (_rafID = requestAnimationFrame(_updateAll));
          _lastScrollTime || _dispatch("scrollStart");
          _lastScrollTime = _getTime$1();
        }
      }, _setBaseDimensions = function _setBaseDimensions2() {
        _baseScreenWidth = _win$1.innerWidth;
        _baseScreenHeight = _win$1.innerHeight;
      }, _onResize = function _onResize2() {
        _scrollers.cache++;
        !_refreshing && !_ignoreResize && !_doc$1.fullscreenElement && !_doc$1.webkitFullscreenElement && (!_ignoreMobileResize || _baseScreenWidth !== _win$1.innerWidth || Math.abs(_win$1.innerHeight - _baseScreenHeight) > _win$1.innerHeight * 0.25) && _resizeDelay.restart(true);
      }, _listeners = {}, _emptyArray = [], _media = [], _creatingMedia, _lastMediaTick, _onMediaChange = function _onMediaChange2(e) {
        var tick = gsap$12.ticker.frame, matches = [], i = 0, index;
        if (_lastMediaTick !== tick || _startup$1) {
          _revertAll();
          for (; i < _media.length; i += 4) {
            index = _win$1.matchMedia(_media[i]).matches;
            if (index !== _media[i + 3]) {
              _media[i + 3] = index;
              index ? matches.push(i) : _revertAll(1, _media[i]) || _isFunction(_media[i + 2]) && _media[i + 2]();
            }
          }
          _revertRecorded();
          for (i = 0; i < matches.length; i++) {
            index = matches[i];
            _creatingMedia = _media[index];
            _media[index + 2] = _media[index + 1](e);
          }
          _creatingMedia = 0;
          _coreInitted$1 && _refreshAll(0, 1);
          _lastMediaTick = tick;
          _dispatch("matchMedia");
        }
      }, _softRefresh = function _softRefresh2() {
        return _removeListener$1(ScrollTrigger$12, "scrollEnd", _softRefresh2) || _refreshAll(true);
      }, _dispatch = function _dispatch2(type) {
        return _listeners[type] && _listeners[type].map(function(f) {
          return f();
        }) || _emptyArray;
      }, _savedStyles = [], _revertRecorded = function _revertRecorded2(media) {
        for (var i = 0; i < _savedStyles.length; i += 5) {
          if (!media || _savedStyles[i + 4] === media) {
            _savedStyles[i].style.cssText = _savedStyles[i + 1];
            _savedStyles[i].getBBox && _savedStyles[i].setAttribute("transform", _savedStyles[i + 2] || "");
            _savedStyles[i + 3].uncache = 1;
          }
        }
      }, _revertAll = function _revertAll2(kill, media) {
        var trigger;
        for (_i = 0; _i < _triggers.length; _i++) {
          trigger = _triggers[_i];
          if (!media || trigger.media === media) {
            if (kill) {
              trigger.kill(1);
            } else {
              trigger.revert();
            }
          }
        }
        media && _revertRecorded(media);
        media || _dispatch("revert");
      }, _clearScrollMemory = function _clearScrollMemory2() {
        return _scrollers.cache++ && _scrollers.forEach(function(obj) {
          return typeof obj === "function" && (obj.rec = 0);
        });
      }, _refreshingAll, _refreshID = 0, _refreshAll = function _refreshAll2(force, skipRevert) {
        if (_lastScrollTime && !force) {
          _addListener$1(ScrollTrigger$12, "scrollEnd", _softRefresh);
          return;
        }
        _refreshingAll = true;
        var refreshInits = _dispatch("refreshInit");
        _sort && ScrollTrigger$12.sort();
        skipRevert || _revertAll();
        _triggers.slice(0).forEach(function(t) {
          return t.refresh();
        });
        _triggers.forEach(function(t) {
          return t.vars.end === "max" && t.setPositions(t.start, _maxScroll(t.scroller, t._dir));
        });
        refreshInits.forEach(function(result) {
          return result && result.render && result.render(-1);
        });
        _clearScrollMemory();
        _resizeDelay.pause();
        _refreshID++;
        _refreshingAll = false;
        _dispatch("refresh");
      }, _lastScroll = 0, _direction = 1, _primary, _updateAll = function _updateAll2() {
        if (!_refreshingAll) {
          ScrollTrigger$12.isUpdating = true;
          _primary && _primary.update(0);
          var l = _triggers.length, time = _getTime$1(), recordVelocity = time - _time1 >= 50, scroll = l && _triggers[0].scroll();
          _direction = _lastScroll > scroll ? -1 : 1;
          _lastScroll = scroll;
          if (recordVelocity) {
            if (_lastScrollTime && !_pointerIsDown && time - _lastScrollTime > 200) {
              _lastScrollTime = 0;
              _dispatch("scrollEnd");
            }
            _time2 = _time1;
            _time1 = time;
          }
          if (_direction < 0) {
            _i = l;
            while (_i-- > 0) {
              _triggers[_i] && _triggers[_i].update(0, recordVelocity);
            }
            _direction = 1;
          } else {
            for (_i = 0; _i < l; _i++) {
              _triggers[_i] && _triggers[_i].update(0, recordVelocity);
            }
          }
          ScrollTrigger$12.isUpdating = false;
        }
        _rafID = 0;
      }, _propNamesToCopy = [_left, _top, _bottom, _right, _margin + _Bottom, _margin + _Right, _margin + _Top, _margin + _Left, "display", "flexShrink", "float", "zIndex", "gridColumnStart", "gridColumnEnd", "gridRowStart", "gridRowEnd", "gridArea", "justifySelf", "alignSelf", "placeSelf", "order"], _stateProps = _propNamesToCopy.concat([_width, _height, "boxSizing", "max" + _Width, "max" + _Height, "position", _margin, _padding, _padding + _Top, _padding + _Right, _padding + _Bottom, _padding + _Left]), _swapPinOut = function _swapPinOut2(pin, spacer, state) {
        _setState(state);
        var cache = pin._gsap;
        if (cache.spacerIsNative) {
          _setState(cache.spacerState);
        } else if (pin.parentNode === spacer) {
          var parent = spacer.parentNode;
          if (parent) {
            parent.insertBefore(pin, spacer);
            parent.removeChild(spacer);
          }
        }
      }, _swapPinIn = function _swapPinIn2(pin, spacer, cs, spacerState) {
        if (pin.parentNode !== spacer) {
          var i = _propNamesToCopy.length, spacerStyle = spacer.style, pinStyle = pin.style, p;
          while (i--) {
            p = _propNamesToCopy[i];
            spacerStyle[p] = cs[p];
          }
          spacerStyle.position = cs.position === "absolute" ? "absolute" : "relative";
          cs.display === "inline" && (spacerStyle.display = "inline-block");
          pinStyle[_bottom] = pinStyle[_right] = spacerStyle.flexBasis = "auto";
          spacerStyle.overflow = "visible";
          spacerStyle.boxSizing = "border-box";
          spacerStyle[_width] = _getSize(pin, _horizontal) + _px;
          spacerStyle[_height] = _getSize(pin, _vertical) + _px;
          spacerStyle[_padding] = pinStyle[_margin] = pinStyle[_top] = pinStyle[_left] = "0";
          _setState(spacerState);
          pinStyle[_width] = pinStyle["max" + _Width] = cs[_width];
          pinStyle[_height] = pinStyle["max" + _Height] = cs[_height];
          pinStyle[_padding] = cs[_padding];
          pin.parentNode.insertBefore(spacer, pin);
          spacer.appendChild(pin);
        }
      }, _capsExp = /([A-Z])/g, _setState = function _setState2(state) {
        if (state) {
          var style = state.t.style, l = state.length, i = 0, p, value;
          (state.t._gsap || gsap$12.core.getCache(state.t)).uncache = 1;
          for (; i < l; i += 2) {
            value = state[i + 1];
            p = state[i];
            if (value) {
              style[p] = value;
            } else if (style[p]) {
              style.removeProperty(p.replace(_capsExp, "-$1").toLowerCase());
            }
          }
        }
      }, _getState = function _getState2(element) {
        var l = _stateProps.length, style = element.style, state = [], i = 0;
        for (; i < l; i++) {
          state.push(_stateProps[i], style[_stateProps[i]]);
        }
        state.t = element;
        return state;
      }, _copyState = function _copyState2(state, override, omitOffsets) {
        var result = [], l = state.length, i = omitOffsets ? 8 : 0, p;
        for (; i < l; i += 2) {
          p = state[i];
          result.push(p, p in override ? override[p] : state[i + 1]);
        }
        result.t = state.t;
        return result;
      }, _winOffsets = {
        left: 0,
        top: 0
      }, _parsePosition = function _parsePosition2(value, trigger, scrollerSize, direction, scroll, marker, markerScroller, self2, scrollerBounds, borderWidth, useFixedPosition, scrollerMax, containerAnimation) {
        _isFunction(value) && (value = value(self2));
        if (_isString(value) && value.substr(0, 3) === "max") {
          value = scrollerMax + (value.charAt(4) === "=" ? _offsetToPx("0" + value.substr(3), scrollerSize) : 0);
        }
        var time = containerAnimation ? containerAnimation.time() : 0, p1, p2, element;
        containerAnimation && containerAnimation.seek(0);
        if (!_isNumber(value)) {
          _isFunction(trigger) && (trigger = trigger(self2));
          var offsets = value.split(" "), bounds, localOffset, globalOffset, display;
          element = _getTarget(trigger) || _body$1;
          bounds = _getBounds(element) || {};
          if ((!bounds || !bounds.left && !bounds.top) && _getComputedStyle(element).display === "none") {
            display = element.style.display;
            element.style.display = "block";
            bounds = _getBounds(element);
            display ? element.style.display = display : element.style.removeProperty("display");
          }
          localOffset = _offsetToPx(offsets[0], bounds[direction.d]);
          globalOffset = _offsetToPx(offsets[1] || "0", scrollerSize);
          value = bounds[direction.p] - scrollerBounds[direction.p] - borderWidth + localOffset + scroll - globalOffset;
          markerScroller && _positionMarker(markerScroller, globalOffset, direction, scrollerSize - globalOffset < 20 || markerScroller._isStart && globalOffset > 20);
          scrollerSize -= scrollerSize - globalOffset;
        } else if (markerScroller) {
          _positionMarker(markerScroller, scrollerSize, direction, true);
        }
        if (marker) {
          var position = value + scrollerSize, isStart = marker._isStart;
          p1 = "scroll" + direction.d2;
          _positionMarker(marker, position, direction, isStart && position > 20 || !isStart && (useFixedPosition ? Math.max(_body$1[p1], _docEl$1[p1]) : marker.parentNode[p1]) <= position + 1);
          if (useFixedPosition) {
            scrollerBounds = _getBounds(markerScroller);
            useFixedPosition && (marker.style[direction.op.p] = scrollerBounds[direction.op.p] - direction.op.m - marker._offset + _px);
          }
        }
        if (containerAnimation && element) {
          p1 = _getBounds(element);
          containerAnimation.seek(scrollerMax);
          p2 = _getBounds(element);
          containerAnimation._caScrollDist = p1[direction.p] - p2[direction.p];
          value = value / containerAnimation._caScrollDist * scrollerMax;
        }
        containerAnimation && containerAnimation.seek(time);
        return containerAnimation ? value : Math.round(value);
      }, _prefixExp = /(webkit|moz|length|cssText|inset)/i, _reparent = function _reparent2(element, parent, top, left) {
        if (element.parentNode !== parent) {
          var style = element.style, p, cs;
          if (parent === _body$1) {
            element._stOrig = style.cssText;
            cs = _getComputedStyle(element);
            for (p in cs) {
              if (!+p && !_prefixExp.test(p) && cs[p] && typeof style[p] === "string" && p !== "0") {
                style[p] = cs[p];
              }
            }
            style.top = top;
            style.left = left;
          } else {
            style.cssText = element._stOrig;
          }
          gsap$12.core.getCache(element).uncache = 1;
          parent.appendChild(element);
        }
      }, _getTweenCreator = function _getTweenCreator2(scroller, direction) {
        var getScroll = _getScrollFunc(scroller, direction), prop = "_scroll" + direction.p2, lastScroll1, lastScroll2, getTween = function getTween2(scrollTo, vars, initialValue, change1, change2) {
          var tween = getTween2.tween, onComplete = vars.onComplete, modifiers = {};
          initialValue = initialValue || getScroll();
          change2 = change1 && change2 || 0;
          change1 = change1 || scrollTo - initialValue;
          tween && tween.kill();
          lastScroll1 = Math.round(initialValue);
          vars[prop] = scrollTo;
          vars.modifiers = modifiers;
          modifiers[prop] = function(value) {
            value = _round(getScroll());
            if (value !== lastScroll1 && value !== lastScroll2 && Math.abs(value - lastScroll1) > 2 && Math.abs(value - lastScroll2) > 2) {
              tween.kill();
              getTween2.tween = 0;
            } else {
              value = initialValue + change1 * tween.ratio + change2 * tween.ratio * tween.ratio;
            }
            lastScroll2 = lastScroll1;
            return lastScroll1 = _round(value);
          };
          vars.onComplete = function() {
            getTween2.tween = 0;
            onComplete && onComplete.call(tween);
          };
          tween = getTween2.tween = gsap$12.to(scroller, vars);
          return tween;
        };
        scroller[prop] = getScroll;
        getScroll.wheelHandler = function() {
          return getTween.tween && getTween.tween.kill() && (getTween.tween = 0);
        };
        _addListener$1(scroller, "wheel", getScroll.wheelHandler);
        return getTween;
      };
      var ScrollTrigger$12 = function() {
        function ScrollTrigger3(vars, animation) {
          _coreInitted$1 || ScrollTrigger3.register(gsap$12) || console.warn("Please gsap.registerPlugin(ScrollTrigger)");
          this.init(vars, animation);
        }
        var _proto = ScrollTrigger3.prototype;
        _proto.init = function init3(vars, animation) {
          this.progress = this.start = 0;
          this.vars && this.kill(true, true);
          if (!_enabled) {
            this.update = this.refresh = this.kill = _passThrough;
            return;
          }
          vars = _setDefaults(_isString(vars) || _isNumber(vars) || vars.nodeType ? {
            trigger: vars
          } : vars, _defaults);
          var _vars = vars, onUpdate = _vars.onUpdate, toggleClass = _vars.toggleClass, id = _vars.id, onToggle = _vars.onToggle, onRefresh = _vars.onRefresh, scrub = _vars.scrub, trigger = _vars.trigger, pin = _vars.pin, pinSpacing = _vars.pinSpacing, invalidateOnRefresh = _vars.invalidateOnRefresh, anticipatePin = _vars.anticipatePin, onScrubComplete = _vars.onScrubComplete, onSnapComplete = _vars.onSnapComplete, once = _vars.once, snap = _vars.snap, pinReparent = _vars.pinReparent, pinSpacer = _vars.pinSpacer, containerAnimation = _vars.containerAnimation, fastScrollEnd = _vars.fastScrollEnd, preventOverlaps = _vars.preventOverlaps, direction = vars.horizontal || vars.containerAnimation && vars.horizontal !== false ? _horizontal : _vertical, isToggle = !scrub && scrub !== 0, scroller = _getTarget(vars.scroller || _win$1), scrollerCache = gsap$12.core.getCache(scroller), isViewport = _isViewport$1(scroller), useFixedPosition = ("pinType" in vars ? vars.pinType : _getProxyProp(scroller, "pinType") || isViewport && "fixed") === "fixed", callbacks = [vars.onEnter, vars.onLeave, vars.onEnterBack, vars.onLeaveBack], toggleActions = isToggle && vars.toggleActions.split(" "), markers = "markers" in vars ? vars.markers : _defaults.markers, borderWidth = isViewport ? 0 : parseFloat(_getComputedStyle(scroller)["border" + direction.p2 + _Width]) || 0, self2 = this, onRefreshInit = vars.onRefreshInit && function() {
            return vars.onRefreshInit(self2);
          }, getScrollerSize = _getSizeFunc(scroller, isViewport, direction), getScrollerOffsets = _getOffsetsFunc(scroller, isViewport), lastSnap = 0, lastRefresh = 0, scrollFunc = _getScrollFunc(scroller, direction), tweenTo, pinCache, snapFunc, scroll1, scroll2, start, end, markerStart, markerEnd, markerStartTrigger, markerEndTrigger, markerVars, change, pinOriginalState, pinActiveState, pinState, spacer, offset, pinGetter, pinSetter, pinStart, pinChange, spacingStart, spacerState, markerStartSetter, markerEndSetter, cs, snap1, snap2, scrubTween, scrubSmooth, snapDurClamp, snapDelayedCall, prevProgress, prevScroll, prevAnimProgress, caMarkerSetter, customRevertReturn;
          self2.media = _creatingMedia;
          self2._dir = direction;
          anticipatePin *= 45;
          self2.scroller = scroller;
          self2.scroll = containerAnimation ? containerAnimation.time.bind(containerAnimation) : scrollFunc;
          scroll1 = scrollFunc();
          self2.vars = vars;
          animation = animation || vars.animation;
          if ("refreshPriority" in vars) {
            _sort = 1;
            vars.refreshPriority === -9999 && (_primary = self2);
          }
          scrollerCache.tweenScroll = scrollerCache.tweenScroll || {
            top: _getTweenCreator(scroller, _vertical),
            left: _getTweenCreator(scroller, _horizontal)
          };
          self2.tweenTo = tweenTo = scrollerCache.tweenScroll[direction.p];
          self2.scrubDuration = function(value) {
            scrubSmooth = _isNumber(value) && value;
            if (!scrubSmooth) {
              scrubTween && scrubTween.progress(1).kill();
              scrubTween = 0;
            } else {
              scrubTween ? scrubTween.duration(value) : scrubTween = gsap$12.to(animation, {
                ease: "expo",
                totalProgress: "+=0.001",
                duration: scrubSmooth,
                paused: true,
                onComplete: function onComplete() {
                  return onScrubComplete && onScrubComplete(self2);
                }
              });
            }
          };
          if (animation) {
            animation.vars.lazy = false;
            animation._initted || animation.vars.immediateRender !== false && vars.immediateRender !== false && animation.render(0, true, true);
            self2.animation = animation.pause();
            animation.scrollTrigger = self2;
            self2.scrubDuration(scrub);
            snap1 = 0;
            id || (id = animation.vars.id);
          }
          _triggers.push(self2);
          if (snap) {
            if (!_isObject(snap) || snap.push) {
              snap = {
                snapTo: snap
              };
            }
            "scrollBehavior" in _body$1.style && gsap$12.set(isViewport ? [_body$1, _docEl$1] : scroller, {
              scrollBehavior: "auto"
            });
            snapFunc = _isFunction(snap.snapTo) ? snap.snapTo : snap.snapTo === "labels" ? _getClosestLabel(animation) : snap.snapTo === "labelsDirectional" ? _getLabelAtDirection(animation) : snap.directional !== false ? function(value, st) {
              return _snapDirectional(snap.snapTo)(value, _getTime$1() - lastRefresh < 500 ? 0 : st.direction);
            } : gsap$12.utils.snap(snap.snapTo);
            snapDurClamp = snap.duration || {
              min: 0.1,
              max: 2
            };
            snapDurClamp = _isObject(snapDurClamp) ? _clamp$1(snapDurClamp.min, snapDurClamp.max) : _clamp$1(snapDurClamp, snapDurClamp);
            snapDelayedCall = gsap$12.delayedCall(snap.delay || scrubSmooth / 2 || 0.1, function() {
              var scroll = scrollFunc(), refreshedRecently = _getTime$1() - lastRefresh < 500, tween = tweenTo.tween;
              if ((refreshedRecently || Math.abs(self2.getVelocity()) < 10) && !tween && !_pointerIsDown && lastSnap !== scroll) {
                var progress = (scroll - start) / change, totalProgress = animation && !isToggle ? animation.totalProgress() : progress, velocity = refreshedRecently ? 0 : (totalProgress - snap2) / (_getTime$1() - _time2) * 1e3 || 0, change1 = gsap$12.utils.clamp(-progress, 1 - progress, _abs(velocity / 2) * velocity / 0.185), naturalEnd = progress + (snap.inertia === false ? 0 : change1), endValue = _clamp$1(0, 1, snapFunc(naturalEnd, self2)), endScroll = Math.round(start + endValue * change), _snap = snap, onStart = _snap.onStart, _onInterrupt = _snap.onInterrupt, _onComplete = _snap.onComplete;
                if (scroll <= end && scroll >= start && endScroll !== scroll) {
                  if (tween && !tween._initted && tween.data <= _abs(endScroll - scroll)) {
                    return;
                  }
                  if (snap.inertia === false) {
                    change1 = endValue - progress;
                  }
                  tweenTo(endScroll, {
                    duration: snapDurClamp(_abs(Math.max(_abs(naturalEnd - totalProgress), _abs(endValue - totalProgress)) * 0.185 / velocity / 0.05 || 0)),
                    ease: snap.ease || "power3",
                    data: _abs(endScroll - scroll),
                    onInterrupt: function onInterrupt() {
                      return snapDelayedCall.restart(true) && _onInterrupt && _onInterrupt(self2);
                    },
                    onComplete: function onComplete() {
                      self2.update();
                      lastSnap = scrollFunc();
                      snap1 = snap2 = animation && !isToggle ? animation.totalProgress() : self2.progress;
                      onSnapComplete && onSnapComplete(self2);
                      _onComplete && _onComplete(self2);
                    }
                  }, scroll, change1 * change, endScroll - scroll - change1 * change);
                  onStart && onStart(self2, tweenTo.tween);
                }
              } else if (self2.isActive && lastSnap !== scroll) {
                snapDelayedCall.restart(true);
              }
            }).pause();
          }
          id && (_ids[id] = self2);
          trigger = self2.trigger = _getTarget(trigger || pin);
          customRevertReturn = trigger && trigger._gsap && trigger._gsap.stRevert;
          customRevertReturn && (customRevertReturn = customRevertReturn(self2));
          pin = pin === true ? trigger : _getTarget(pin);
          _isString(toggleClass) && (toggleClass = {
            targets: trigger,
            className: toggleClass
          });
          if (pin) {
            pinSpacing === false || pinSpacing === _margin || (pinSpacing = !pinSpacing && _getComputedStyle(pin.parentNode).display === "flex" ? false : _padding);
            self2.pin = pin;
            vars.force3D !== false && gsap$12.set(pin, {
              force3D: true
            });
            pinCache = gsap$12.core.getCache(pin);
            if (!pinCache.spacer) {
              if (pinSpacer) {
                pinSpacer = _getTarget(pinSpacer);
                pinSpacer && !pinSpacer.nodeType && (pinSpacer = pinSpacer.current || pinSpacer.nativeElement);
                pinCache.spacerIsNative = !!pinSpacer;
                pinSpacer && (pinCache.spacerState = _getState(pinSpacer));
              }
              pinCache.spacer = spacer = pinSpacer || _doc$1.createElement("div");
              spacer.classList.add("pin-spacer");
              id && spacer.classList.add("pin-spacer-" + id);
              pinCache.pinState = pinOriginalState = _getState(pin);
            } else {
              pinOriginalState = pinCache.pinState;
            }
            self2.spacer = spacer = pinCache.spacer;
            cs = _getComputedStyle(pin);
            spacingStart = cs[pinSpacing + direction.os2];
            pinGetter = gsap$12.getProperty(pin);
            pinSetter = gsap$12.quickSetter(pin, direction.a, _px);
            _swapPinIn(pin, spacer, cs);
            pinState = _getState(pin);
          }
          if (markers) {
            markerVars = _isObject(markers) ? _setDefaults(markers, _markerDefaults) : _markerDefaults;
            markerStartTrigger = _createMarker("scroller-start", id, scroller, direction, markerVars, 0);
            markerEndTrigger = _createMarker("scroller-end", id, scroller, direction, markerVars, 0, markerStartTrigger);
            offset = markerStartTrigger["offset" + direction.op.d2];
            var content = _getTarget(_getProxyProp(scroller, "content") || scroller);
            markerStart = this.markerStart = _createMarker("start", id, content, direction, markerVars, offset, 0, containerAnimation);
            markerEnd = this.markerEnd = _createMarker("end", id, content, direction, markerVars, offset, 0, containerAnimation);
            containerAnimation && (caMarkerSetter = gsap$12.quickSetter([markerStart, markerEnd], direction.a, _px));
            if (!useFixedPosition && !(_proxies.length && _getProxyProp(scroller, "fixedMarkers") === true)) {
              _makePositionable(isViewport ? _body$1 : scroller);
              gsap$12.set([markerStartTrigger, markerEndTrigger], {
                force3D: true
              });
              markerStartSetter = gsap$12.quickSetter(markerStartTrigger, direction.a, _px);
              markerEndSetter = gsap$12.quickSetter(markerEndTrigger, direction.a, _px);
            }
          }
          if (containerAnimation) {
            var oldOnUpdate = containerAnimation.vars.onUpdate, oldParams = containerAnimation.vars.onUpdateParams;
            containerAnimation.eventCallback("onUpdate", function() {
              self2.update(0, 0, 1);
              oldOnUpdate && oldOnUpdate.apply(oldParams || []);
            });
          }
          self2.previous = function() {
            return _triggers[_triggers.indexOf(self2) - 1];
          };
          self2.next = function() {
            return _triggers[_triggers.indexOf(self2) + 1];
          };
          self2.revert = function(revert) {
            var r = revert !== false || !self2.enabled, prevRefreshing = _refreshing;
            if (r !== self2.isReverted) {
              if (r) {
                self2.scroll.rec || !_refreshing || !_refreshingAll || (self2.scroll.rec = scrollFunc());
                prevScroll = Math.max(scrollFunc(), self2.scroll.rec || 0);
                prevProgress = self2.progress;
                prevAnimProgress = animation && animation.progress();
              }
              markerStart && [markerStart, markerEnd, markerStartTrigger, markerEndTrigger].forEach(function(m) {
                return m.style.display = r ? "none" : "block";
              });
              r && (_refreshing = 1);
              self2.update(r);
              _refreshing = prevRefreshing;
              pin && (r ? _swapPinOut(pin, spacer, pinOriginalState) : (!pinReparent || !self2.isActive) && _swapPinIn(pin, spacer, _getComputedStyle(pin), spacerState));
              self2.isReverted = r;
            }
          };
          self2.refresh = function(soft, force) {
            if ((_refreshing || !self2.enabled) && !force) {
              return;
            }
            if (pin && soft && _lastScrollTime) {
              _addListener$1(ScrollTrigger3, "scrollEnd", _softRefresh);
              return;
            }
            !_refreshingAll && onRefreshInit && onRefreshInit(self2);
            _refreshing = 1;
            lastRefresh = _getTime$1();
            if (tweenTo.tween) {
              tweenTo.tween.kill();
              tweenTo.tween = 0;
            }
            scrubTween && scrubTween.pause();
            invalidateOnRefresh && animation && animation.time(-0.01, true).invalidate();
            self2.isReverted || self2.revert();
            var size = getScrollerSize(), scrollerBounds = getScrollerOffsets(), max = containerAnimation ? containerAnimation.duration() : _maxScroll(scroller, direction), offset2 = 0, otherPinOffset = 0, parsedEnd = vars.end, parsedEndTrigger = vars.endTrigger || trigger, parsedStart = vars.start || (vars.start === 0 || !trigger ? 0 : pin ? "0 0" : "0 100%"), pinnedContainer = self2.pinnedContainer = vars.pinnedContainer && _getTarget(vars.pinnedContainer), triggerIndex = trigger && Math.max(0, _triggers.indexOf(self2)) || 0, i = triggerIndex, cs2, bounds, scroll, isVertical, override, curTrigger, curPin, oppositeScroll, initted, revertedPins;
            while (i--) {
              curTrigger = _triggers[i];
              curTrigger.end || curTrigger.refresh(0, 1) || (_refreshing = 1);
              curPin = curTrigger.pin;
              if (curPin && (curPin === trigger || curPin === pin) && !curTrigger.isReverted) {
                revertedPins || (revertedPins = []);
                revertedPins.unshift(curTrigger);
                curTrigger.revert();
              }
              if (curTrigger !== _triggers[i]) {
                triggerIndex--;
                i--;
              }
            }
            _isFunction(parsedStart) && (parsedStart = parsedStart(self2));
            start = _parsePosition(parsedStart, trigger, size, direction, scrollFunc(), markerStart, markerStartTrigger, self2, scrollerBounds, borderWidth, useFixedPosition, max, containerAnimation) || (pin ? -1e-3 : 0);
            _isFunction(parsedEnd) && (parsedEnd = parsedEnd(self2));
            if (_isString(parsedEnd) && !parsedEnd.indexOf("+=")) {
              if (~parsedEnd.indexOf(" ")) {
                parsedEnd = (_isString(parsedStart) ? parsedStart.split(" ")[0] : "") + parsedEnd;
              } else {
                offset2 = _offsetToPx(parsedEnd.substr(2), size);
                parsedEnd = _isString(parsedStart) ? parsedStart : start + offset2;
                parsedEndTrigger = trigger;
              }
            }
            end = Math.max(start, _parsePosition(parsedEnd || (parsedEndTrigger ? "100% 0" : max), parsedEndTrigger, size, direction, scrollFunc() + offset2, markerEnd, markerEndTrigger, self2, scrollerBounds, borderWidth, useFixedPosition, max, containerAnimation)) || -1e-3;
            change = end - start || (start -= 0.01) && 1e-3;
            offset2 = 0;
            i = triggerIndex;
            while (i--) {
              curTrigger = _triggers[i];
              curPin = curTrigger.pin;
              if (curPin && curTrigger.start - curTrigger._pinPush < start && !containerAnimation && curTrigger.end > 0) {
                cs2 = curTrigger.end - curTrigger.start;
                if ((curPin === trigger || curPin === pinnedContainer) && !_isNumber(parsedStart)) {
                  offset2 += cs2 * (1 - curTrigger.progress);
                }
                curPin === pin && (otherPinOffset += cs2);
              }
            }
            start += offset2;
            end += offset2;
            self2._pinPush = otherPinOffset;
            if (markerStart && offset2) {
              cs2 = {};
              cs2[direction.a] = "+=" + offset2;
              pinnedContainer && (cs2[direction.p] = "-=" + scrollFunc());
              gsap$12.set([markerStart, markerEnd], cs2);
            }
            if (pin) {
              cs2 = _getComputedStyle(pin);
              isVertical = direction === _vertical;
              scroll = scrollFunc();
              pinStart = parseFloat(pinGetter(direction.a)) + otherPinOffset;
              !max && end > 1 && ((isViewport ? _body$1 : scroller).style["overflow-" + direction.a] = "scroll");
              _swapPinIn(pin, spacer, cs2);
              pinState = _getState(pin);
              bounds = _getBounds(pin, true);
              oppositeScroll = useFixedPosition && _getScrollFunc(scroller, isVertical ? _horizontal : _vertical)();
              if (pinSpacing) {
                spacerState = [pinSpacing + direction.os2, change + otherPinOffset + _px];
                spacerState.t = spacer;
                i = pinSpacing === _padding ? _getSize(pin, direction) + change + otherPinOffset : 0;
                i && spacerState.push(direction.d, i + _px);
                _setState(spacerState);
                useFixedPosition && scrollFunc(prevScroll);
              }
              if (useFixedPosition) {
                override = {
                  top: bounds.top + (isVertical ? scroll - start : oppositeScroll) + _px,
                  left: bounds.left + (isVertical ? oppositeScroll : scroll - start) + _px,
                  boxSizing: "border-box",
                  position: "fixed"
                };
                override[_width] = override["max" + _Width] = Math.ceil(bounds.width) + _px;
                override[_height] = override["max" + _Height] = Math.ceil(bounds.height) + _px;
                override[_margin] = override[_margin + _Top] = override[_margin + _Right] = override[_margin + _Bottom] = override[_margin + _Left] = "0";
                override[_padding] = cs2[_padding];
                override[_padding + _Top] = cs2[_padding + _Top];
                override[_padding + _Right] = cs2[_padding + _Right];
                override[_padding + _Bottom] = cs2[_padding + _Bottom];
                override[_padding + _Left] = cs2[_padding + _Left];
                pinActiveState = _copyState(pinOriginalState, override, pinReparent);
              }
              if (animation) {
                initted = animation._initted;
                _suppressOverwrites(1);
                animation.render(animation.duration(), true, true);
                pinChange = pinGetter(direction.a) - pinStart + change + otherPinOffset;
                change !== pinChange && useFixedPosition && pinActiveState.splice(pinActiveState.length - 2, 2);
                animation.render(0, true, true);
                initted || animation.invalidate();
                _suppressOverwrites(0);
              } else {
                pinChange = change;
              }
            } else if (trigger && scrollFunc() && !containerAnimation) {
              bounds = trigger.parentNode;
              while (bounds && bounds !== _body$1) {
                if (bounds._pinOffset) {
                  start -= bounds._pinOffset;
                  end -= bounds._pinOffset;
                }
                bounds = bounds.parentNode;
              }
            }
            revertedPins && revertedPins.forEach(function(t) {
              return t.revert(false);
            });
            self2.start = start;
            self2.end = end;
            scroll1 = scroll2 = scrollFunc();
            if (!containerAnimation) {
              scroll1 < prevScroll && scrollFunc(prevScroll);
              self2.scroll.rec = 0;
            }
            self2.revert(false);
            if (snapDelayedCall) {
              lastSnap = -1;
              self2.isActive && scrollFunc(start + change * prevProgress);
              snapDelayedCall.restart(true);
            }
            _refreshing = 0;
            animation && isToggle && (animation._initted || prevAnimProgress) && animation.progress() !== prevAnimProgress && animation.progress(prevAnimProgress, true).render(animation.time(), true, true);
            if (prevProgress !== self2.progress || containerAnimation) {
              animation && !isToggle && animation.totalProgress(prevProgress, true);
              self2.progress = prevProgress;
              self2.update(0, 0, 1);
            }
            pin && pinSpacing && (spacer._pinOffset = Math.round(self2.progress * pinChange));
            onRefresh && onRefresh(self2);
          };
          self2.getVelocity = function() {
            return (scrollFunc() - scroll2) / (_getTime$1() - _time2) * 1e3 || 0;
          };
          self2.endAnimation = function() {
            _endAnimation(self2.callbackAnimation);
            if (animation) {
              scrubTween ? scrubTween.progress(1) : !animation.paused() ? _endAnimation(animation, animation.reversed()) : isToggle || _endAnimation(animation, self2.direction < 0, 1);
            }
          };
          self2.labelToScroll = function(label) {
            return animation && animation.labels && (start || self2.refresh() || start) + animation.labels[label] / animation.duration() * change || 0;
          };
          self2.getTrailing = function(name) {
            var i = _triggers.indexOf(self2), a = self2.direction > 0 ? _triggers.slice(0, i).reverse() : _triggers.slice(i + 1);
            return (_isString(name) ? a.filter(function(t) {
              return t.vars.preventOverlaps === name;
            }) : a).filter(function(t) {
              return self2.direction > 0 ? t.end <= start : t.start >= end;
            });
          };
          self2.update = function(reset, recordVelocity, forceFake) {
            if (containerAnimation && !forceFake && !reset) {
              return;
            }
            var scroll = self2.scroll(), p = reset ? 0 : (scroll - start) / change, clipped = p < 0 ? 0 : p > 1 ? 1 : p || 0, prevProgress2 = self2.progress, isActive, wasActive, toggleState, action, stateChanged, toggled, isAtMax, isTakingAction;
            if (recordVelocity) {
              scroll2 = scroll1;
              scroll1 = containerAnimation ? scrollFunc() : scroll;
              if (snap) {
                snap2 = snap1;
                snap1 = animation && !isToggle ? animation.totalProgress() : clipped;
              }
            }
            anticipatePin && !clipped && pin && !_refreshing && !_startup$1 && _lastScrollTime && start < scroll + (scroll - scroll2) / (_getTime$1() - _time2) * anticipatePin && (clipped = 1e-4);
            if (clipped !== prevProgress2 && self2.enabled) {
              isActive = self2.isActive = !!clipped && clipped < 1;
              wasActive = !!prevProgress2 && prevProgress2 < 1;
              toggled = isActive !== wasActive;
              stateChanged = toggled || !!clipped !== !!prevProgress2;
              self2.direction = clipped > prevProgress2 ? 1 : -1;
              self2.progress = clipped;
              if (stateChanged && !_refreshing) {
                toggleState = clipped && !prevProgress2 ? 0 : clipped === 1 ? 1 : prevProgress2 === 1 ? 2 : 3;
                if (isToggle) {
                  action = !toggled && toggleActions[toggleState + 1] !== "none" && toggleActions[toggleState + 1] || toggleActions[toggleState];
                  isTakingAction = animation && (action === "complete" || action === "reset" || action in animation);
                }
              }
              preventOverlaps && (toggled || isTakingAction) && (isTakingAction || scrub || !animation) && (_isFunction(preventOverlaps) ? preventOverlaps(self2) : self2.getTrailing(preventOverlaps).forEach(function(t) {
                return t.endAnimation();
              }));
              if (!isToggle) {
                if (scrubTween && !_refreshing && !_startup$1) {
                  (containerAnimation || _primary && _primary !== self2) && scrubTween.render(scrubTween._dp._time - scrubTween._start);
                  if (scrubTween.resetTo) {
                    scrubTween.resetTo("totalProgress", clipped, animation._tTime / animation._tDur);
                  } else {
                    scrubTween.vars.totalProgress = clipped;
                    scrubTween.invalidate().restart();
                  }
                } else if (animation) {
                  animation.totalProgress(clipped, !!_refreshing);
                }
              }
              if (pin) {
                reset && pinSpacing && (spacer.style[pinSpacing + direction.os2] = spacingStart);
                if (!useFixedPosition) {
                  pinSetter(_round(pinStart + pinChange * clipped));
                } else if (stateChanged) {
                  isAtMax = !reset && clipped > prevProgress2 && end + 1 > scroll && scroll + 1 >= _maxScroll(scroller, direction);
                  if (pinReparent) {
                    if (!reset && (isActive || isAtMax)) {
                      var bounds = _getBounds(pin, true), _offset = scroll - start;
                      _reparent(pin, _body$1, bounds.top + (direction === _vertical ? _offset : 0) + _px, bounds.left + (direction === _vertical ? 0 : _offset) + _px);
                    } else {
                      _reparent(pin, spacer);
                    }
                  }
                  _setState(isActive || isAtMax ? pinActiveState : pinState);
                  pinChange !== change && clipped < 1 && isActive || pinSetter(pinStart + (clipped === 1 && !isAtMax ? pinChange : 0));
                }
              }
              snap && !tweenTo.tween && !_refreshing && !_startup$1 && snapDelayedCall.restart(true);
              toggleClass && (toggled || once && clipped && (clipped < 1 || !_limitCallbacks)) && _toArray(toggleClass.targets).forEach(function(el) {
                return el.classList[isActive || once ? "add" : "remove"](toggleClass.className);
              });
              onUpdate && !isToggle && !reset && onUpdate(self2);
              if (stateChanged && !_refreshing) {
                if (isToggle) {
                  if (isTakingAction) {
                    if (action === "complete") {
                      animation.pause().totalProgress(1);
                    } else if (action === "reset") {
                      animation.restart(true).pause();
                    } else if (action === "restart") {
                      animation.restart(true);
                    } else {
                      animation[action]();
                    }
                  }
                  onUpdate && onUpdate(self2);
                }
                if (toggled || !_limitCallbacks) {
                  onToggle && toggled && _callback(self2, onToggle);
                  callbacks[toggleState] && _callback(self2, callbacks[toggleState]);
                  once && (clipped === 1 ? self2.kill(false, 1) : callbacks[toggleState] = 0);
                  if (!toggled) {
                    toggleState = clipped === 1 ? 1 : 3;
                    callbacks[toggleState] && _callback(self2, callbacks[toggleState]);
                  }
                }
                if (fastScrollEnd && !isActive && Math.abs(self2.getVelocity()) > (_isNumber(fastScrollEnd) ? fastScrollEnd : 2500)) {
                  _endAnimation(self2.callbackAnimation);
                  scrubTween ? scrubTween.progress(1) : _endAnimation(animation, !clipped, 1);
                }
              } else if (isToggle && onUpdate && !_refreshing) {
                onUpdate(self2);
              }
            }
            if (markerEndSetter) {
              var n = containerAnimation ? scroll / containerAnimation.duration() * (containerAnimation._caScrollDist || 0) : scroll;
              markerStartSetter(n + (markerStartTrigger._isFlipped ? 1 : 0));
              markerEndSetter(n);
            }
            caMarkerSetter && caMarkerSetter(-scroll / containerAnimation.duration() * (containerAnimation._caScrollDist || 0));
          };
          self2.enable = function(reset, refresh) {
            if (!self2.enabled) {
              self2.enabled = true;
              _addListener$1(scroller, "resize", _onResize);
              _addListener$1(isViewport ? _doc$1 : scroller, "scroll", _onScroll$1);
              onRefreshInit && _addListener$1(ScrollTrigger3, "refreshInit", onRefreshInit);
              if (reset !== false) {
                self2.progress = prevProgress = 0;
                scroll1 = scroll2 = lastSnap = scrollFunc();
              }
              refresh !== false && self2.refresh();
            }
          };
          self2.getTween = function(snap3) {
            return snap3 && tweenTo ? tweenTo.tween : scrubTween;
          };
          self2.setPositions = function(newStart, newEnd) {
            if (pin) {
              pinStart += newStart - start;
              pinChange += newEnd - newStart - change;
            }
            self2.start = start = newStart;
            self2.end = end = newEnd;
            change = newEnd - newStart;
            self2.update();
          };
          self2.disable = function(reset, allowAnimation) {
            if (self2.enabled) {
              reset !== false && self2.revert();
              self2.enabled = self2.isActive = false;
              allowAnimation || scrubTween && scrubTween.pause();
              prevScroll = 0;
              pinCache && (pinCache.uncache = 1);
              onRefreshInit && _removeListener$1(ScrollTrigger3, "refreshInit", onRefreshInit);
              if (snapDelayedCall) {
                snapDelayedCall.pause();
                tweenTo.tween && tweenTo.tween.kill() && (tweenTo.tween = 0);
              }
              if (!isViewport) {
                var i = _triggers.length;
                while (i--) {
                  if (_triggers[i].scroller === scroller && _triggers[i] !== self2) {
                    return;
                  }
                }
                _removeListener$1(scroller, "resize", _onResize);
                _removeListener$1(scroller, "scroll", _onScroll$1);
              }
            }
          };
          self2.kill = function(revert, allowAnimation) {
            self2.disable(revert, allowAnimation);
            scrubTween && !allowAnimation && scrubTween.kill();
            id && delete _ids[id];
            var i = _triggers.indexOf(self2);
            i >= 0 && _triggers.splice(i, 1);
            i === _i && _direction > 0 && _i--;
            i = 0;
            _triggers.forEach(function(t) {
              return t.scroller === self2.scroller && (i = 1);
            });
            i || (self2.scroll.rec = 0);
            if (animation) {
              animation.scrollTrigger = null;
              revert && animation.render(-1);
              allowAnimation || animation.kill();
            }
            markerStart && [markerStart, markerEnd, markerStartTrigger, markerEndTrigger].forEach(function(m) {
              return m.parentNode && m.parentNode.removeChild(m);
            });
            _primary === self2 && (_primary = 0);
            if (pin) {
              pinCache && (pinCache.uncache = 1);
              i = 0;
              _triggers.forEach(function(t) {
                return t.pin === pin && i++;
              });
              i || (pinCache.spacer = 0);
            }
            vars.onKill && vars.onKill(self2);
          };
          self2.enable(false, false);
          customRevertReturn && customRevertReturn(self2);
          !animation || !animation.add || change ? self2.refresh() : gsap$12.delayedCall(0.01, function() {
            return start || end || self2.refresh();
          }) && (change = 0.01) && (start = end = 0);
        };
        ScrollTrigger3.register = function register3(core) {
          if (!_coreInitted$1) {
            gsap$12 = core || _getGSAP$12();
            _windowExists() && window.document && ScrollTrigger3.enable();
            _coreInitted$1 = _enabled;
          }
          return _coreInitted$1;
        };
        ScrollTrigger3.defaults = function defaults(config) {
          if (config) {
            for (var p in config) {
              _defaults[p] = config[p];
            }
          }
          return _defaults;
        };
        ScrollTrigger3.disable = function disable(reset, kill) {
          _enabled = 0;
          _triggers.forEach(function(trigger) {
            return trigger[kill ? "kill" : "disable"](reset);
          });
          _removeListener$1(_win$1, "wheel", _onScroll$1);
          _removeListener$1(_doc$1, "scroll", _onScroll$1);
          clearInterval(_syncInterval);
          _removeListener$1(_doc$1, "touchcancel", _passThrough);
          _removeListener$1(_body$1, "touchstart", _passThrough);
          _multiListener(_removeListener$1, _doc$1, "pointerdown,touchstart,mousedown", _pointerDownHandler);
          _multiListener(_removeListener$1, _doc$1, "pointerup,touchend,mouseup", _pointerUpHandler);
          _resizeDelay.kill();
          _iterateAutoRefresh(_removeListener$1);
          for (var i = 0; i < _scrollers.length; i += 3) {
            _wheelListener(_removeListener$1, _scrollers[i], _scrollers[i + 1]);
            _wheelListener(_removeListener$1, _scrollers[i], _scrollers[i + 2]);
          }
        };
        ScrollTrigger3.enable = function enable() {
          _win$1 = window;
          _doc$1 = document;
          _docEl$1 = _doc$1.documentElement;
          _body$1 = _doc$1.body;
          if (gsap$12) {
            _toArray = gsap$12.utils.toArray;
            _clamp$1 = gsap$12.utils.clamp;
            _suppressOverwrites = gsap$12.core.suppressOverwrites || _passThrough;
            gsap$12.core.globals("ScrollTrigger", ScrollTrigger3);
            if (_body$1) {
              _enabled = 1;
              Observer.register(gsap$12);
              ScrollTrigger3.isTouch = Observer.isTouch;
              _fixIOSBug = Observer.isTouch && /(iPad|iPhone|iPod|Mac)/g.test(navigator.userAgent);
              _addListener$1(_win$1, "wheel", _onScroll$1);
              _root$1 = [_win$1, _doc$1, _docEl$1, _body$1];
              ScrollTrigger3.matchMedia({
                "(orientation: portrait)": function orientationPortrait() {
                  _setBaseDimensions();
                  return _setBaseDimensions;
                }
              });
              _addListener$1(_doc$1, "scroll", _onScroll$1);
              var bodyStyle = _body$1.style, border = bodyStyle.borderTopStyle, bounds, i;
              bodyStyle.borderTopStyle = "solid";
              bounds = _getBounds(_body$1);
              _vertical.m = Math.round(bounds.top + _vertical.sc()) || 0;
              _horizontal.m = Math.round(bounds.left + _horizontal.sc()) || 0;
              border ? bodyStyle.borderTopStyle = border : bodyStyle.removeProperty("border-top-style");
              _syncInterval = setInterval(_sync, 250);
              gsap$12.delayedCall(0.5, function() {
                return _startup$1 = 0;
              });
              _addListener$1(_doc$1, "touchcancel", _passThrough);
              _addListener$1(_body$1, "touchstart", _passThrough);
              _multiListener(_addListener$1, _doc$1, "pointerdown,touchstart,mousedown", _pointerDownHandler);
              _multiListener(_addListener$1, _doc$1, "pointerup,touchend,mouseup", _pointerUpHandler);
              _transformProp = gsap$12.utils.checkPrefix("transform");
              _stateProps.push(_transformProp);
              _coreInitted$1 = _getTime$1();
              _resizeDelay = gsap$12.delayedCall(0.2, _refreshAll).pause();
              _autoRefresh = [_doc$1, "visibilitychange", function() {
                var w = _win$1.innerWidth, h = _win$1.innerHeight;
                if (_doc$1.hidden) {
                  _prevWidth = w;
                  _prevHeight = h;
                } else if (_prevWidth !== w || _prevHeight !== h) {
                  _onResize();
                }
              }, _doc$1, "DOMContentLoaded", _refreshAll, _win$1, "load", _refreshAll, _win$1, "resize", _onResize];
              _iterateAutoRefresh(_addListener$1);
              _triggers.forEach(function(trigger) {
                return trigger.enable(0, 1);
              });
              for (i = 0; i < _scrollers.length; i += 3) {
                _wheelListener(_removeListener$1, _scrollers[i], _scrollers[i + 1]);
                _wheelListener(_removeListener$1, _scrollers[i], _scrollers[i + 2]);
              }
            }
          }
        };
        ScrollTrigger3.config = function config(vars) {
          "limitCallbacks" in vars && (_limitCallbacks = !!vars.limitCallbacks);
          var ms = vars.syncInterval;
          ms && clearInterval(_syncInterval) || (_syncInterval = ms) && setInterval(_sync, ms);
          "ignoreMobileResize" in vars && (_ignoreMobileResize = ScrollTrigger3.isTouch === 1 && vars.ignoreMobileResize);
          if ("autoRefreshEvents" in vars) {
            _iterateAutoRefresh(_removeListener$1) || _iterateAutoRefresh(_addListener$1, vars.autoRefreshEvents || "none");
            _ignoreResize = (vars.autoRefreshEvents + "").indexOf("resize") === -1;
          }
        };
        ScrollTrigger3.scrollerProxy = function scrollerProxy(target, vars) {
          var t = _getTarget(target), i = _scrollers.indexOf(t), isViewport = _isViewport$1(t);
          if (~i) {
            _scrollers.splice(i, isViewport ? 6 : 2);
          }
          if (vars) {
            isViewport ? _proxies.unshift(_win$1, vars, _body$1, vars, _docEl$1, vars) : _proxies.unshift(t, vars);
          }
        };
        ScrollTrigger3.matchMedia = function matchMedia(vars) {
          var mq, p, i, func, result;
          for (p in vars) {
            i = _media.indexOf(p);
            func = vars[p];
            _creatingMedia = p;
            if (p === "all") {
              func();
            } else {
              mq = _win$1.matchMedia(p);
              if (mq) {
                mq.matches && (result = func());
                if (~i) {
                  _media[i + 1] = _combineFunc(_media[i + 1], func);
                  _media[i + 2] = _combineFunc(_media[i + 2], result);
                } else {
                  i = _media.length;
                  _media.push(p, func, result);
                  mq.addListener ? mq.addListener(_onMediaChange) : mq.addEventListener("change", _onMediaChange);
                }
                _media[i + 3] = mq.matches;
              }
            }
            _creatingMedia = 0;
          }
          return _media;
        };
        ScrollTrigger3.clearMatchMedia = function clearMatchMedia(query) {
          query || (_media.length = 0);
          query = _media.indexOf(query);
          query >= 0 && _media.splice(query, 4);
        };
        ScrollTrigger3.isInViewport = function isInViewport(element, ratio, horizontal) {
          var bounds = (_isString(element) ? _getTarget(element) : element).getBoundingClientRect(), offset = bounds[horizontal ? _width : _height] * ratio || 0;
          return horizontal ? bounds.right - offset > 0 && bounds.left + offset < _win$1.innerWidth : bounds.bottom - offset > 0 && bounds.top + offset < _win$1.innerHeight;
        };
        ScrollTrigger3.positionInViewport = function positionInViewport(element, referencePoint, horizontal) {
          _isString(element) && (element = _getTarget(element));
          var bounds = element.getBoundingClientRect(), size = bounds[horizontal ? _width : _height], offset = referencePoint == null ? size / 2 : referencePoint in _keywords ? _keywords[referencePoint] * size : ~referencePoint.indexOf("%") ? parseFloat(referencePoint) * size / 100 : parseFloat(referencePoint) || 0;
          return horizontal ? (bounds.left + offset) / _win$1.innerWidth : (bounds.top + offset) / _win$1.innerHeight;
        };
        return ScrollTrigger3;
      }();
      ScrollTrigger$12.version = "3.10.4";
      ScrollTrigger$12.saveStyles = function(targets) {
        return targets ? _toArray(targets).forEach(function(target) {
          if (target && target.style) {
            var i = _savedStyles.indexOf(target);
            i >= 0 && _savedStyles.splice(i, 5);
            _savedStyles.push(target, target.style.cssText, target.getBBox && target.getAttribute("transform"), gsap$12.core.getCache(target), _creatingMedia);
          }
        }) : _savedStyles;
      };
      ScrollTrigger$12.revert = function(soft, media) {
        return _revertAll(!soft, media);
      };
      ScrollTrigger$12.create = function(vars, animation) {
        return new ScrollTrigger$12(vars, animation);
      };
      ScrollTrigger$12.refresh = function(safe) {
        return safe ? _onResize() : (_coreInitted$1 || ScrollTrigger$12.register()) && _refreshAll(true);
      };
      ScrollTrigger$12.update = _updateAll;
      ScrollTrigger$12.clearScrollMemory = _clearScrollMemory;
      ScrollTrigger$12.maxScroll = function(element, horizontal) {
        return _maxScroll(element, horizontal ? _horizontal : _vertical);
      };
      ScrollTrigger$12.getScrollFunc = function(element, horizontal) {
        return _getScrollFunc(_getTarget(element), horizontal ? _horizontal : _vertical);
      };
      ScrollTrigger$12.getById = function(id) {
        return _ids[id];
      };
      ScrollTrigger$12.getAll = function() {
        return _triggers.filter(function(t) {
          return t.vars.id !== "ScrollSmoother";
        });
      };
      ScrollTrigger$12.isScrolling = function() {
        return !!_lastScrollTime;
      };
      ScrollTrigger$12.snapDirectional = _snapDirectional;
      ScrollTrigger$12.addEventListener = function(type, callback) {
        var a = _listeners[type] || (_listeners[type] = []);
        ~a.indexOf(callback) || a.push(callback);
      };
      ScrollTrigger$12.removeEventListener = function(type, callback) {
        var a = _listeners[type], i = a && a.indexOf(callback);
        i >= 0 && a.splice(i, 1);
      };
      ScrollTrigger$12.batch = function(targets, vars) {
        var result = [], varsCopy = {}, interval = vars.interval || 0.016, batchMax = vars.batchMax || 1e9, proxyCallback = function proxyCallback2(type, callback) {
          var elements = [], triggers = [], delay = gsap$12.delayedCall(interval, function() {
            callback(elements, triggers);
            elements = [];
            triggers = [];
          }).pause();
          return function(self2) {
            elements.length || delay.restart(true);
            elements.push(self2.trigger);
            triggers.push(self2);
            batchMax <= elements.length && delay.progress(1);
          };
        }, p;
        for (p in vars) {
          varsCopy[p] = p.substr(0, 2) === "on" && _isFunction(vars[p]) && p !== "onRefreshInit" ? proxyCallback(p, vars[p]) : vars[p];
        }
        if (_isFunction(batchMax)) {
          batchMax = batchMax();
          _addListener$1(ScrollTrigger$12, "refresh", function() {
            return batchMax = vars.batchMax();
          });
        }
        _toArray(targets).forEach(function(target) {
          var config = {};
          for (p in varsCopy) {
            config[p] = varsCopy[p];
          }
          config.trigger = target;
          result.push(ScrollTrigger$12.create(config));
        });
        return result;
      };
      var _clampScrollAndGetDurationMultiplier = function _clampScrollAndGetDurationMultiplier2(scrollFunc, current, end, max) {
        current > max ? scrollFunc(max) : current < 0 && scrollFunc(0);
        return end > max ? (max - current) / (end - current) : end < 0 ? current / (current - end) : 1;
      }, _allowNativePanning = function _allowNativePanning2(target, direction) {
        if (direction === true) {
          target.style.removeProperty("touch-action");
        } else {
          target.style.touchAction = direction === true ? "auto" : direction ? "pan-" + direction + (Observer.isTouch ? " pinch-zoom" : "") : "none";
        }
        target === _docEl$1 && _allowNativePanning2(_body$1, direction);
      }, _overflow = {
        auto: 1,
        scroll: 1
      }, _nestedScroll = function _nestedScroll2(_ref5) {
        var event = _ref5.event, target = _ref5.target, axis = _ref5.axis;
        var node = (event.changedTouches ? event.changedTouches[0] : event).target, cache = node._gsap || gsap$12.core.getCache(node), time = _getTime$1(), cs;
        if (!cache._isScrollT || time - cache._isScrollT > 2e3) {
          while (node && node.scrollHeight <= node.clientHeight) {
            node = node.parentNode;
          }
          cache._isScroll = node && !_isViewport$1(node) && node !== target && (_overflow[(cs = _getComputedStyle(node)).overflowY] || _overflow[cs.overflowX]);
          cache._isScrollT = time;
        }
        (cache._isScroll || axis === "x") && (event._gsapAllow = true);
      }, _inputObserver = function _inputObserver2(target, type, inputs, nested) {
        return Observer.create({
          target,
          capture: true,
          debounce: false,
          lockAxis: true,
          type,
          onWheel: nested = nested && _nestedScroll,
          onPress: nested,
          onDrag: nested,
          onScroll: nested,
          onEnable: function onEnable() {
            return inputs && _addListener$1(_doc$1, Observer.eventTypes[0], _captureInputs, false, true);
          },
          onDisable: function onDisable() {
            return _removeListener$1(_doc$1, Observer.eventTypes[0], _captureInputs, true);
          }
        });
      }, _inputExp = /(input|label|select|textarea)/i, _inputIsFocused, _captureInputs = function _captureInputs2(e) {
        var isInput = _inputExp.test(e.target.tagName);
        if (isInput || _inputIsFocused) {
          e._gsapAllow = true;
          _inputIsFocused = isInput;
        }
      }, _getScrollNormalizer = function _getScrollNormalizer2(vars) {
        _isObject(vars) || (vars = {});
        vars.preventDefault = vars.isNormalizer = vars.allowClicks = true;
        vars.type || (vars.type = "wheel,touch");
        vars.debounce = !!vars.debounce;
        vars.id = vars.id || "normalizer";
        var _vars2 = vars, normalizeScrollX = _vars2.normalizeScrollX, momentum = _vars2.momentum, allowNestedScroll = _vars2.allowNestedScroll, self2, maxY, target = _getTarget(vars.target) || _docEl$1, smoother = gsap$12.core.globals().ScrollSmoother, content = _fixIOSBug && (vars.content && _getTarget(vars.content) || smoother && smoother.get() && smoother.get().content()), scrollFuncY = _getScrollFunc(target, _vertical), scrollFuncX = _getScrollFunc(target, _horizontal), scale = 1, initialScale = (Observer.isTouch && _win$1.visualViewport ? _win$1.visualViewport.scale * _win$1.visualViewport.width : _win$1.outerWidth) / _win$1.innerWidth, wheelRefresh = 0, resolveMomentumDuration = _isFunction(momentum) ? function() {
          return momentum(self2);
        } : function() {
          return momentum || 2.8;
        }, skipTouchMove, lastRefreshID, inputObserver = _inputObserver(target, vars.type, true, allowNestedScroll), resumeTouchMove = function resumeTouchMove2() {
          return skipTouchMove = false;
        }, scrollClampX = _passThrough, scrollClampY = _passThrough, updateClamps = function updateClamps2() {
          maxY = _maxScroll(target, _vertical);
          scrollClampY = _clamp$1(_fixIOSBug ? 1 : 0, maxY);
          normalizeScrollX && (scrollClampX = _clamp$1(0, _maxScroll(target, _horizontal)));
          lastRefreshID = _refreshID;
        }, ignoreDrag = function ignoreDrag2() {
          if (skipTouchMove) {
            requestAnimationFrame(resumeTouchMove);
            var offset = _round(self2.deltaY / 2), scroll = scrollClampY(scrollFuncY.v - offset);
            if (content && scroll !== scrollFuncY.v + scrollFuncY.offset) {
              scrollFuncY.offset = scroll - scrollFuncY.v;
              content.style.transform = "translateY(" + -scrollFuncY.offset + "px)";
              content._gsap && (content._gsap.y = -scrollFuncY.offset + "px");
              scrollFuncY.cacheID = _scrollers.cache;
              _updateAll();
            }
            return true;
          }
          if (content) {
            content.style.transform = "translateY(0px)";
            scrollFuncY.offset = scrollFuncY.cacheID = 0;
            content._gsap && (content._gsap.y = "0px");
          }
          skipTouchMove = true;
        }, tween, startScrollX, startScrollY, onStopDelayedCall, onResize = function onResize2() {
          updateClamps();
          if (tween.isActive() && tween.vars.scrollY > maxY) {
            scrollFuncY() > maxY ? tween.progress(1) && scrollFuncY(maxY) : tween.resetTo("scrollY", maxY);
          }
        };
        vars.ignoreCheck = function(e) {
          return _fixIOSBug && e.type === "touchmove" && ignoreDrag() || scale > 1.05 && e.type !== "touchstart" || self2.isGesturing || e.touches && e.touches.length > 1;
        };
        vars.onPress = function() {
          var prevScale = scale;
          scale = _round((_win$1.visualViewport && _win$1.visualViewport.scale || 1) / initialScale);
          tween.pause();
          prevScale !== scale && _allowNativePanning(target, scale > 1.01 ? true : normalizeScrollX ? false : "x");
          skipTouchMove = false;
          startScrollX = scrollFuncX();
          startScrollY = scrollFuncY();
          updateClamps();
          lastRefreshID = _refreshID;
        };
        vars.onRelease = vars.onGestureStart = function(self3, wasDragging) {
          if (content) {
            content.style.transform = "translateY(0px)";
            scrollFuncY.offset = scrollFuncY.cacheID = 0;
            content._gsap && (content._gsap.y = "0px");
          }
          if (!wasDragging) {
            onStopDelayedCall.restart(true);
          } else {
            _scrollers.cache++;
            var dur = resolveMomentumDuration(), currentScroll, endScroll;
            if (normalizeScrollX) {
              currentScroll = scrollFuncX();
              endScroll = currentScroll + dur * 0.05 * -self3.velocityX / 0.227;
              dur *= _clampScrollAndGetDurationMultiplier(scrollFuncX, currentScroll, endScroll, _maxScroll(target, _horizontal));
              tween.vars.scrollX = scrollClampX(endScroll);
            }
            currentScroll = scrollFuncY();
            endScroll = currentScroll + dur * 0.05 * -self3.velocityY / 0.227;
            dur *= _clampScrollAndGetDurationMultiplier(scrollFuncY, currentScroll, endScroll, _maxScroll(target, _vertical));
            tween.vars.scrollY = scrollClampY(endScroll);
            tween.invalidate().duration(dur).play(0.01);
            if (_fixIOSBug && tween.vars.scrollY >= maxY || currentScroll >= maxY - 1) {
              gsap$12.to({}, {
                onUpdate: onResize,
                duration: dur
              });
            }
          }
        };
        vars.onWheel = function() {
          tween._ts && tween.pause();
          if (_getTime$1() - wheelRefresh > 1e3) {
            lastRefreshID = 0;
            wheelRefresh = _getTime$1();
          }
        };
        vars.onChange = function(self3, dx, dy, xArray, yArray) {
          _refreshID !== lastRefreshID && updateClamps();
          dx && normalizeScrollX && scrollFuncX(scrollClampX(xArray[2] === dx ? startScrollX + (self3.startX - self3.x) : scrollFuncX() + dx - xArray[1]));
          dy && scrollFuncY(scrollClampY(yArray[2] === dy ? startScrollY + (self3.startY - self3.y) : scrollFuncY() + dy - yArray[1]));
          _updateAll();
        };
        vars.onEnable = function() {
          _allowNativePanning(target, normalizeScrollX ? false : "x");
          _addListener$1(_win$1, "resize", onResize);
          inputObserver.enable();
        };
        vars.onDisable = function() {
          _allowNativePanning(target, true);
          _removeListener$1(_win$1, "resize", onResize);
          inputObserver.kill();
        };
        self2 = new Observer(vars);
        self2.iOS = _fixIOSBug;
        _fixIOSBug && !scrollFuncY() && scrollFuncY(1);
        onStopDelayedCall = self2._dc;
        tween = gsap$12.to(self2, {
          ease: "power4",
          paused: true,
          scrollX: normalizeScrollX ? "+=0.1" : "+=0",
          scrollY: "+=0.1",
          onComplete: onStopDelayedCall.vars.onComplete
        });
        return self2;
      };
      ScrollTrigger$12.sort = function(func) {
        return _triggers.sort(func || function(a, b) {
          return (a.vars.refreshPriority || 0) * -1e6 + a.start - (b.start + (b.vars.refreshPriority || 0) * -1e6);
        });
      };
      ScrollTrigger$12.observe = function(vars) {
        return new Observer(vars);
      };
      ScrollTrigger$12.normalizeScroll = function(vars) {
        if (typeof vars === "undefined") {
          return _normalizer$1;
        }
        if (vars === true && _normalizer$1) {
          return _normalizer$1.enable();
        }
        if (vars === false) {
          return _normalizer$1 && _normalizer$1.kill();
        }
        var normalizer = vars instanceof Observer ? vars : _getScrollNormalizer(vars);
        _normalizer$1 && _normalizer$1.target === normalizer.target && _normalizer$1.kill();
        _isViewport$1(normalizer.target) && (_normalizer$1 = normalizer);
        return normalizer;
      };
      ScrollTrigger$12.core = {
        _getVelocityProp,
        _inputObserver,
        _scrollers,
        _proxies,
        bridge: {
          ss: function ss() {
            _lastScrollTime || _dispatch("scrollStart");
            _lastScrollTime = _getTime$1();
          },
          ref: function ref() {
            return _refreshing;
          }
        }
      };
      _getGSAP$12() && gsap$12.registerPlugin(ScrollTrigger$12);
      exports2.ScrollTrigger = ScrollTrigger$12;
      exports2.default = ScrollTrigger$12;
      if (typeof window === "undefined" || window !== exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
      } else {
        delete window.default;
      }
    });
  }
});

// node_modules/react-gsap/dist/react-gsap.esm.js
var import_react = __toESM(require_react());
var import_react_is = __toESM(require_react_is());
var import_ScrollTrigger = __toESM(require_ScrollTrigger());
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it;
  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it)
        o = it;
      var i = 0;
      return function() {
        if (i >= o.length)
          return {
            done: true
          };
        return {
          done: false,
          value: o[i++]
        };
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  it = o[Symbol.iterator]();
  return it.next.bind(it);
}
var PlayState;
(function(PlayState2) {
  PlayState2["play"] = "play";
  PlayState2["restart"] = "restart";
  PlayState2["reverse"] = "reverse";
  PlayState2["restartReverse"] = "restartReverse";
  PlayState2["stop"] = "stop";
  PlayState2["stopEnd"] = "stopEnd";
  PlayState2["pause"] = "pause";
  PlayState2["resume"] = "resume";
})(PlayState || (PlayState = {}));
if (!String.prototype.startsWith) {
  String.prototype.startsWith = function(searchString, position) {
    position = position || 0;
    return this.indexOf(searchString, position) === position;
  };
}
var setPlayState = function setPlayState2(playState, prevPlayState, tween) {
  if (tween === void 0) {
    tween = null;
  }
  if (tween && playState && playState !== prevPlayState) {
    if (playState === PlayState.play) {
      tween.play();
    } else if (playState === PlayState.restart) {
      tween.restart(true);
    } else if (playState === PlayState.reverse) {
      tween.reverse();
    } else if (playState === PlayState.restartReverse) {
      tween.reverse(0);
    } else if (playState === PlayState.stop) {
      tween.pause(0);
    } else if (playState === PlayState.stopEnd) {
      tween.reverse(0);
      tween.pause();
    } else if (playState === PlayState.pause) {
      tween.pause();
    } else if (playState === PlayState.resume) {
      tween.resume();
    }
  }
};
var setInitialPlayState = function setInitialPlayState2(tweenOrTimeline, props) {
  var playState = props.playState;
  if (playState) {
    setPlayState(playState, PlayState.play, tweenOrTimeline);
  }
};
var getInitialPaused = function getInitialPaused2(playState) {
  return playState && (playState === PlayState.stop || playState === PlayState.stopEnd || playState === PlayState.pause);
};
var getTweenFunction = function getTweenFunction2(targets, props, context) {
  var _context$getPlugins;
  var _props$duration = props.duration, duration = _props$duration === void 0 ? 1 : _props$duration, from = props.from, to = props.to, stagger = props.stagger, playState = props.playState, onCompleteAll = props.onCompleteAll, onCompleteAllParams = props.onCompleteAllParams, onCompleteAllScope = props.onCompleteAllScope, onStartAll = props.onStartAll, vars = _objectWithoutPropertiesLoose(props, ["children", "wrapper", "duration", "from", "to", "stagger", "progress", "totalProgress", "playState", "disabled", "onlyInvalidateTo", "onCompleteAll", "onCompleteAllParams", "onCompleteAllScope", "onStartAll", "position", "target"]);
  var tweenFunction;
  var paused = getInitialPaused(playState);
  var plugins = (_context$getPlugins = context === null || context === void 0 ? void 0 : context.getPlugins(context === null || context === void 0 ? void 0 : context.plugins, targets)) !== null && _context$getPlugins !== void 0 ? _context$getPlugins : {};
  if (from && to) {
    tweenFunction = gsapWithCSS.fromTo(targets, from, _extends({
      stagger,
      duration,
      paused
    }, to, vars, plugins));
  } else if (to) {
    tweenFunction = gsapWithCSS.to(targets, _extends({
      stagger,
      duration,
      paused
    }, to, vars, plugins));
  } else {
    tweenFunction = gsapWithCSS.from(targets, _extends({
      stagger,
      duration,
      paused
    }, from, vars, plugins));
  }
  if (Array.isArray(tweenFunction)) {
    tweenFunction.forEach(function(t) {
      t.paused(false);
    });
    tweenFunction = gsapWithCSS.timeline(_extends({}, vars, {
      tweens: tweenFunction,
      smoothChildTiming: true,
      onComplete: onCompleteAll,
      onCompleteParams: onCompleteAllParams,
      onCompleteScope: onCompleteAllScope,
      onStart: onStartAll
    }));
  }
  return tweenFunction;
};
var isEqual = function isEqual2(obj1, obj2) {
  return JSON.stringify(obj1) === JSON.stringify(obj2);
};
function getReactNode(dom, traverseUp) {
  if (traverseUp === void 0) {
    traverseUp = 0;
  }
  var key = Object.keys(dom !== null && dom !== void 0 ? dom : {}).find(function(key2) {
    return key2.startsWith("__reactInternalInstance$") || key2.startsWith("__reactFiber$");
  });
  var domFiber = key && dom[key];
  if (!domFiber)
    return null;
  if (domFiber._currentElement) {
    var _compFiber = domFiber._currentElement._owner;
    for (var i = 0; i < traverseUp; i++) {
      _compFiber = _compFiber._currentElement._owner;
    }
    return _compFiber._instance;
  }
  if (domFiber.stateNode) {
    return domFiber.stateNode;
  }
  var getCompFiber = function getCompFiber2(fiber) {
    var parentFiber = fiber["return"];
    while (typeof parentFiber.type == "string") {
      parentFiber = parentFiber["return"];
    }
    return parentFiber;
  };
  var compFiber = getCompFiber(domFiber);
  for (var _i = 0; _i < traverseUp; _i++) {
    compFiber = getCompFiber(compFiber);
  }
  return compFiber.stateNode;
}
var getRefProp = function getRefProp2(child, addTarget) {
  if (child.props.innerRef) {
    return {
      innerRef: function innerRef(target) {
        addTarget(target);
        var innerRef2 = child.props.innerRef;
        if (typeof innerRef2 === "function")
          innerRef2(target);
        else if (innerRef2)
          innerRef2.current = target;
      }
    };
  }
  return {
    ref: function ref(target) {
      addTarget(target);
      var ref2 = child.ref;
      if (typeof ref2 === "function")
        ref2(target);
      else if (ref2)
        ref2.current = target;
    }
  };
};
var setOrAddTarget = function setOrAddTarget2(target, setTarget, addTarget) {
  var reactNode = getReactNode(target);
  if (reactNode) {
    addTarget(reactNode);
  } else if (target) {
    Object.keys(target).forEach(function(key) {
      var elementRef = target[key];
      if (typeof elementRef === "object" && elementRef.current) {
        if (Array.isArray(elementRef.current)) {
          elementRef.current.forEach(function(singleRef) {
            setTarget(key, singleRef);
          });
        } else {
          setTarget(key, elementRef.current);
        }
      }
    });
  }
};
var getTargetRefProp = function getTargetRefProp2(child, setTarget, addTarget) {
  if (child.props.innerRef) {
    return {
      innerRef: function innerRef(target) {
        setOrAddTarget(target, setTarget, addTarget);
        var innerRef2 = child.props.innerRef;
        if (typeof innerRef2 === "function")
          innerRef2(target);
        else if (innerRef2)
          innerRef2.current = target;
      }
    };
  }
  return {
    ref: function ref(target) {
      setOrAddTarget(target, setTarget, addTarget);
      var ref2 = child.ref;
      if (typeof ref2 === "function")
        ref2(target);
      else if (ref2)
        ref2.current = target;
    }
  };
};
var nullishCoalescing = function nullishCoalescing2(value, ifNullish) {
  if (value === null || typeof value === "undefined") {
    return ifNullish;
  }
  return value;
};
var setProps = function setProps2(tweenOrTimeline, props, prevProps) {
  if (props.progress !== void 0 && props.progress !== (prevProps === null || prevProps === void 0 ? void 0 : prevProps.progress)) {
    tweenOrTimeline.progress(props.progress);
  }
  if (props.totalProgress !== void 0 && props.totalProgress !== (prevProps === null || prevProps === void 0 ? void 0 : prevProps.totalProgress)) {
    tweenOrTimeline.totalProgress(props.totalProgress);
  }
  if (tweenOrTimeline.duration !== void 0 && props.duration && props.duration !== (prevProps === null || prevProps === void 0 ? void 0 : prevProps.duration)) {
    tweenOrTimeline.duration(props.duration);
  }
};
var Context = import_react.default.createContext({
  registerConsumer: function registerConsumer() {
  },
  getPlugins: function getPlugins() {
  },
  plugins: {}
});
var Provider = function(_React$Component) {
  _inheritsLoose(Provider2, _React$Component);
  function Provider2(props) {
    var _this;
    _this = _React$Component.call(this, props) || this;
    _this.consumers = [];
    _this.plugins = {};
    _this.registerConsumer = _this.registerConsumer.bind(_assertThisInitialized(_this));
    _this.getContextValue = _this.getContextValue.bind(_assertThisInitialized(_this));
    _this.getPlugin = _this.getPlugin.bind(_assertThisInitialized(_this));
    _this.getPlugins = _this.getPlugins.bind(_assertThisInitialized(_this));
    _this.renderWithProvider = _this.renderWithProvider.bind(_assertThisInitialized(_this));
    return _this;
  }
  var _proto = Provider2.prototype;
  _proto.registerConsumer = function registerConsumer2(consumer) {
    this.consumers.push(consumer);
  };
  _proto.getContextValue = function getContextValue(plugin) {
    if (plugin === void 0) {
      plugin = {};
    }
    return {
      registerConsumer: this.registerConsumer,
      plugins: plugin,
      getPlugins: this.getPlugins
    };
  };
  _proto.getPlugin = function getPlugin(props, targets) {
    return {};
  };
  _proto.getPlugins = function getPlugins2(plugins, targets) {
    var _this2 = this;
    return Object.keys(plugins !== null && plugins !== void 0 ? plugins : {}).reduce(function(acc, plugin) {
      if (Object.prototype.hasOwnProperty.call(plugins, plugin)) {
        var _extends2;
        return _extends({}, acc, (_extends2 = {}, _extends2[plugin] = _this2.getPlugin(plugins[plugin], targets), _extends2));
      }
      return acc;
    }, {});
  };
  _proto.renderWithProvider = function renderWithProvider(output, plugin) {
    return import_react.default.createElement(Context.Provider, {
      value: this.getContextValue(plugin)
    }, output);
  };
  return Provider2;
}(import_react.default.Component);
Provider.contextType = Context;
var gsap;
var _interpolate;
var _getProp;
var _getGSAP = function _getGSAP2() {
  return gsap || typeof window !== "undefined" && (gsap = window.gsap) && gsap.registerPlugin && gsap;
};
function getDistance(p1, p2) {
  return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
}
function getCircleLength(el) {
  return 2 * Math.PI * parseFloat(nullishCoalescing(el.getAttribute("r"), "1") || "0");
}
function getRectLength(el) {
  return parseFloat(nullishCoalescing(el.getAttribute("width"), "1") || "0") * 2 + parseFloat(nullishCoalescing(el.getAttribute("height"), "1") || "0") * 2;
}
function getLineLength(el) {
  return getDistance({
    x: parseFloat(nullishCoalescing(el.getAttribute("x1"), "1") || "0"),
    y: parseFloat(nullishCoalescing(el.getAttribute("y1"), "1") || "0")
  }, {
    x: parseFloat(nullishCoalescing(el.getAttribute("x2"), "1") || "0"),
    y: parseFloat(nullishCoalescing(el.getAttribute("y2"), "1") || "0")
  });
}
function getPolylineLength(el) {
  var points = el.points;
  var totalLength = 0;
  var previousPos = void 0;
  for (var i = 0; i < points.numberOfItems; i++) {
    var currentPos = points.getItem(i);
    if (previousPos)
      totalLength += getDistance(previousPos, currentPos);
    previousPos = currentPos;
  }
  return totalLength;
}
function getPolygonLength(el) {
  var points = el.points;
  return getPolylineLength(el) + getDistance(points.getItem(points.numberOfItems - 1), points.getItem(0));
}
function getPathLength(el) {
  if (!el.hasAttribute("d")) {
    return el.getTotalLength();
  }
  var d = el.getAttribute("d");
  var pathString = d ? d.replace(/m/gi, "M") : null;
  if (!pathString) {
    return el.getTotalLength();
  }
  var paths = pathString.split("M").filter(function(path) {
    return path !== "";
  }).map(function(path) {
    return "M" + path;
  });
  if (paths.length === 1) {
    return el.getTotalLength();
  }
  var maxLength = 0;
  paths.forEach(function(path) {
    var pathElement = document.createElementNS("http://www.w3.org/2000/svg", "path");
    pathElement.setAttribute("d", path);
    maxLength = Math.max(maxLength, pathElement.getTotalLength());
  });
  return maxLength;
}
function getTotalLength(el) {
  if (el.getTotalLength) {
    return getPathLength(el);
  }
  switch (el.tagName.toLowerCase()) {
    case "circle":
      return getCircleLength(el);
    case "rect":
      return getRectLength(el);
    case "line":
      return getLineLength(el);
    case "polyline":
      return getPolylineLength(el);
    case "polygon":
      return getPolygonLength(el);
    default:
      return 0;
  }
}
var SvgDrawPlugin = {
  version: "2.0.0",
  name: "svgDraw",
  register: function register(core, Plugin, propTween) {
    gsap = core;
    _interpolate = gsap.utils.interpolate;
    _getProp = gsap.getProperty;
  },
  init: function init(target, value, _tween, index, targets) {
    var length = getTotalLength(target);
    var lengthParam = value;
    var offsetParam = 0;
    if (Array.isArray(value)) {
      lengthParam = value[0];
      if (value.length >= 2) {
        offsetParam = value[1] * -1;
      }
    }
    var data = this;
    data.target = target;
    data.strokeDashoffset = _interpolate(_getProp(target, "stroke-dashoffset"), length * offsetParam);
    data.strokeDasharray = _interpolate(_getProp(target, "stroke-dasharray"), [lengthParam * length, length]);
  },
  render: function render(progress, data) {
    data.target.setAttribute("stroke-dashoffset", data.strokeDashoffset(progress));
    data.target.setAttribute("stroke-dasharray", data.strokeDasharray(progress));
  }
};
_getGSAP() && gsap.registerPlugin(SvgDrawPlugin);
var gsap$1;
var _interpolate$1;
var _format;
var _getGSAP$1 = function _getGSAP3() {
  return gsap$1 || typeof window !== "undefined" && (gsap$1 = window.gsap) && gsap$1.registerPlugin && gsap$1;
};
var CountPlugin = {
  version: "1.0.0",
  name: "count",
  register: function register2(core, Plugin, propTween) {
    gsap$1 = core;
    _interpolate$1 = gsap$1.utils.interpolate;
    _format = function _format2(value) {
      return parseInt(value.toString(), 10);
    };
  },
  init: function init2(target, value, _tween, index, targets) {
    var inputValue = value;
    var format = _format;
    if (typeof value === "object") {
      inputValue = nullishCoalescing(value.value, 0);
      if (value.format) {
        format = value.format;
      }
    }
    var initialCount = parseFloat(target.innerText);
    var data = this;
    data.target = target;
    data.count = _interpolate$1(initialCount, parseFloat(inputValue.toString()));
    data.format = format;
  },
  render: function render2(progress, data) {
    data.target.innerText = data.format(data.count(progress));
  }
};
_getGSAP$1() && gsap$1.registerPlugin(CountPlugin);
gsapWithCSS.registerPlugin(SvgDrawPlugin);
gsapWithCSS.registerPlugin(CountPlugin);
var Tween = function(_React$Component) {
  _inheritsLoose(Tween2, _React$Component);
  function Tween2(props) {
    var _this;
    _this = _React$Component.call(this, props) || this;
    _this.targets = [];
    _this.addTarget = _this.addTarget.bind(_assertThisInitialized(_this));
    return _this;
  }
  var _proto = Tween2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    this.createTween();
    setProps(this.tween, this.props);
    setInitialPlayState(this.tween, this.props);
    this.context.registerConsumer(this);
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    if (this.tween) {
      this.tween.kill();
    }
  };
  _proto.getSnapshotBeforeUpdate = function getSnapshotBeforeUpdate() {
    this.targets = [];
    return null;
  };
  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    var _this$props = this.props, children = _this$props.children, to = _this$props.to, playState = _this$props.playState, disabled = _this$props.disabled, onlyInvalidateTo = _this$props.onlyInvalidateTo, vars = _objectWithoutPropertiesLoose(_this$props, ["children", "wrapper", "duration", "from", "to", "stagger", "progress", "totalProgress", "playState", "disabled", "onlyInvalidateTo", "onCompleteAll", "onCompleteAllParams", "onCompleteAllScope", "onStartAll", "position", "target"]);
    if (import_react.default.Children.count(prevProps.children) !== import_react.default.Children.count(children)) {
      this.createTween();
    }
    if (disabled) {
      return;
    }
    setProps(this.tween, this.props, prevProps);
    if (!isEqual(to, prevProps.to)) {
      if (!this.tween.getChildren) {
        this.tween.vars = _extends({}, to, vars);
        if (onlyInvalidateTo) {
          var progressTmp = this.tween.progress();
          this.tween.progress(0).invalidate().progress(progressTmp);
        } else {
          this.tween.invalidate();
        }
      } else {
        var delay = 0;
        this.tween.getChildren(false, true, false).forEach(function(tween) {
          tween.vars = _extends({}, to, vars, {
            delay
          });
          tween.invalidate();
        });
      }
      if (!this.tween.paused()) {
        this.tween.restart();
      }
    }
    setPlayState(playState, prevProps.playState, this.tween);
  };
  _proto.createTween = function createTween() {
    if (this.tween) {
      this.tween.kill();
    }
    if (this.props.children) {
      this.tween = getTweenFunction(this.targets, this.props, this.context);
    } else {
      this.tween = function() {
      };
    }
  };
  _proto.getGSAP = function getGSAP() {
    return this.tween;
  };
  _proto.setGSAP = function setGSAP(tween) {
    this.tween = tween;
  };
  _proto.addTarget = function addTarget(target) {
    if (target !== null) {
      this.targets.push(target);
    }
  };
  _proto.getTargets = function getTargets() {
    return this.targets;
  };
  _proto.render = function render3() {
    var _this2 = this;
    var _this$props2 = this.props, children = _this$props2.children, wrapper = _this$props2.wrapper;
    var output = import_react.default.createElement(import_react.Fragment, null, import_react.default.Children.map(children, function(child) {
      return import_react.default.cloneElement(child, getRefProp(child, _this2.addTarget));
    }));
    if (wrapper) {
      return import_react.default.cloneElement(wrapper, [], output);
    }
    return output;
  };
  return Tween2;
}(import_react.default.Component);
Tween.displayName = "Tween";
Tween.contextType = Context;
var Timeline = function(_Provider) {
  _inheritsLoose(Timeline2, _Provider);
  function Timeline2(props) {
    var _this;
    _this = _Provider.call(this, props) || this;
    _this.targets = /* @__PURE__ */ new Map();
    _this.addTarget = _this.addTarget.bind(_assertThisInitialized(_this));
    _this.setTarget = _this.setTarget.bind(_assertThisInitialized(_this));
    return _this;
  }
  var _proto = Timeline2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    this.createTimeline();
    setProps(this.timeline, this.props);
    setInitialPlayState(this.timeline, this.props);
    this.context.registerConsumer(this);
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    this.timeline.kill();
  };
  _proto.getSnapshotBeforeUpdate = function getSnapshotBeforeUpdate() {
    this.targets = /* @__PURE__ */ new Map();
    return null;
  };
  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    var _this$props = this.props, children = _this$props.children, playState = _this$props.playState;
    if (import_react.default.Children.count(prevProps.children) !== import_react.default.Children.count(children)) {
      this.createTimeline();
    }
    setProps(this.timeline, this.props, prevProps);
    setPlayState(playState, prevProps.playState, this.timeline);
  };
  _proto.createTimeline = function createTimeline() {
    var _this$context$getPlug, _this$context, _this$context2, _this2 = this;
    var _this$props2 = this.props, playState = _this$props2.playState, labels = _this$props2.labels, vars = _objectWithoutPropertiesLoose(_this$props2, ["children", "target", "duration", "progress", "totalProgress", "playState", "labels", "position"]);
    if (this.timeline) {
      this.timeline.kill();
    }
    var plugins = (_this$context$getPlug = (_this$context = this.context) === null || _this$context === void 0 ? void 0 : _this$context.getPlugins((_this$context2 = this.context) === null || _this$context2 === void 0 ? void 0 : _this$context2.plugins, this.targets)) !== null && _this$context$getPlug !== void 0 ? _this$context$getPlug : {};
    this.timeline = gsapWithCSS.timeline(_extends({
      smoothChildTiming: true,
      paused: getInitialPaused(playState)
    }, vars, plugins));
    if (labels) {
      labels.forEach(function(label) {
        _this2.timeline.addLabel(label.label, label.position);
      });
    }
    this.consumers.forEach(function(consumer) {
      if (consumer.tween && !consumer.props.children) {
        var _consumer$props = consumer.props, _position = _consumer$props.position, _target = _consumer$props.target, stagger = _consumer$props.stagger, _vars = _objectWithoutPropertiesLoose(_consumer$props, ["position", "target", "stagger"]);
        var targets = null;
        if (_target !== null && typeof _target !== "undefined") {
          targets = _this2.targets.get(_target);
        }
        var tween = getTweenFunction(
          nullishCoalescing(targets, Array.from(_this2.targets.values())),
          _extends({
            stagger
          }, _vars)
        );
        _this2.timeline.add(tween, nullishCoalescing(_position, "+=0"));
        consumer.setGSAP(tween);
      } else {
        var _position2 = consumer.props.position;
        _this2.timeline.add(consumer.getGSAP(), nullishCoalescing(_position2, "+=0"));
      }
    });
  };
  _proto.getGSAP = function getGSAP() {
    return this.timeline;
  };
  _proto.addTarget = function addTarget(target) {
    if (target !== null) {
      this.targets.set(this.targets.size, target);
    }
  };
  _proto.setTarget = function setTarget(key, target) {
    if (target !== null) {
      if (this.targets.has(key)) {
        var targets = this.targets.get(key);
        if (Array.isArray(targets)) {
          this.targets.set(key, [].concat(targets, [target]));
        } else {
          this.targets.set(key, [targets, target]);
        }
      } else {
        this.targets.set(key, target);
      }
    }
  };
  _proto.setTargets = function setTargets(targets) {
    this.targets = targets;
  };
  _proto.getTargets = function getTargets() {
    return this.targets;
  };
  _proto.cloneElement = function cloneElement(child) {
    return import_react.default.cloneElement(child, getTargetRefProp(child, this.setTarget, this.addTarget));
  };
  _proto.renderTarget = function renderTarget(target) {
    var _this3 = this;
    if (!target) {
      return null;
    }
    if ((0, import_react_is.isForwardRef)(target)) {
      return this.cloneElement(target);
    }
    return import_react.default.createElement(import_react.Fragment, null, import_react.default.Children.map(target, function(child) {
      if ((0, import_react_is.isFragment)(child)) {
        return import_react.default.Children.map(child.props.children, function(fragmentChild) {
          return _this3.cloneElement(fragmentChild);
        });
      }
      return _this3.cloneElement(child);
    }));
  };
  _proto.render = function render3() {
    var _this$props3 = this.props, target = _this$props3.target, children = _this$props3.children, wrapper = _this$props3.wrapper;
    var renderedTarget = this.renderTarget(target);
    var output = import_react.default.createElement(import_react.Fragment, null, renderedTarget, children);
    if (wrapper) {
      output = import_react.default.cloneElement(wrapper, [], output);
    }
    return this.renderWithProvider(output);
  };
  return Timeline2;
}(Provider);
Timeline.displayName = "Timeline";
Timeline.defaultProps = {
  playState: PlayState.play
};
var EntryState;
(function(EntryState2) {
  EntryState2[EntryState2["unknown"] = 0] = "unknown";
  EntryState2[EntryState2["entered"] = 1] = "entered";
  EntryState2[EntryState2["exited"] = 2] = "exited";
})(EntryState || (EntryState = {}));
var Reveal = function(_Provider) {
  _inheritsLoose(Reveal2, _Provider);
  function Reveal2() {
    var _this;
    _this = _Provider.apply(this, arguments) || this;
    _this.triggerRef = null;
    _this.observer = null;
    _this.intersectionObserverCallback = function(entries) {
      var _this$props = _this.props, repeat = _this$props.repeat, threshold = _this$props.threshold;
      var state = EntryState.unknown;
      for (var _iterator = _createForOfIteratorHelperLoose(entries), _step; !(_step = _iterator()).done; ) {
        var entry = _step.value;
        if (entry.isIntersecting && entry.intersectionRatio >= threshold) {
          _this.timeline.play();
          state = EntryState.entered;
          break;
        } else if (!entry.isIntersecting) {
          state = EntryState.exited;
          break;
        }
      }
      if (!repeat && state === EntryState.entered) {
        _this.killIntersectionObserver();
      } else if (repeat && state === EntryState.exited) {
        _this.timeline.pause(0);
      }
    };
    return _this;
  }
  var _proto = Reveal2.prototype;
  _proto.init = function init3() {
    this.createTimeline();
    this.createIntersectionObserver();
  };
  _proto.kill = function kill() {
    this.killTimeline();
    this.killIntersectionObserver();
  };
  _proto.componentDidMount = function componentDidMount() {
    this.init();
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    this.kill();
  };
  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    var _this$props2 = this.props, children = _this$props2.children, trigger = _this$props2.trigger;
    if (import_react.default.Children.count(prevProps.children) !== import_react.default.Children.count(children)) {
      this.init();
    }
    if (prevProps.trigger !== trigger) {
      this.init();
    }
  };
  _proto.createTimeline = function createTimeline() {
    var _this2 = this;
    this.killTimeline();
    this.timeline = gsapWithCSS.timeline({
      smoothChildTiming: true,
      paused: true
    });
    this.consumers.forEach(function(consumer) {
      var position = consumer.props.position;
      _this2.timeline.add(consumer.getGSAP().play(), nullishCoalescing(position, 0));
    });
  };
  _proto.killTimeline = function killTimeline() {
    if (this.timeline) {
      this.timeline.kill();
    }
  };
  _proto.createIntersectionObserver = function createIntersectionObserver() {
    var _this3 = this;
    var _this$props3 = this.props, root = _this$props3.root, rootMargin = _this$props3.rootMargin, threshold = _this$props3.threshold;
    var options = {
      root,
      rootMargin,
      threshold: [0, threshold]
    };
    this.observer = new IntersectionObserver(this.intersectionObserverCallback, options);
    if (!this.triggerRef) {
      this.consumers.forEach(function(consumer) {
        consumer.getTargets().forEach(function(target) {
          _this3.observer && _this3.observer.observe(target);
        });
      });
    } else {
      this.observer && this.observer.observe(this.triggerRef);
    }
  };
  _proto.killIntersectionObserver = function killIntersectionObserver() {
    this.unobserveAll();
    this.observer = null;
  };
  _proto.unobserveAll = function unobserveAll() {
    var _this4 = this;
    if (this.observer) {
      if (!this.triggerRef) {
        this.consumers.forEach(function(consumer) {
          consumer.getTargets().forEach(function(target) {
            _this4.observer && _this4.observer.unobserve(target);
          });
        });
      } else {
        this.observer && this.observer.unobserve(this.triggerRef);
      }
    }
  };
  _proto.getGSAP = function getGSAP() {
    return this.timeline;
  };
  _proto.render = function render3() {
    var _this5 = this;
    var _this$props4 = this.props, children = _this$props4.children, trigger = _this$props4.trigger;
    var output = trigger ? import_react.default.createElement(trigger.type, Object.assign({}, trigger.props, {
      ref: function ref(trigger2) {
        return _this5.triggerRef = trigger2;
      }
    }), children) : children;
    return this.renderWithProvider(output);
  };
  return Reveal2;
}(Provider);
Reveal.displayName = "Reveal";
Reveal.defaultProps = {
  trigger: null,
  repeat: false,
  root: null,
  rootMargin: "0px",
  threshold: 0.66
};
gsapWithCSS.registerPlugin(import_ScrollTrigger.ScrollTrigger);
var ScrollTrigger = function(_Provider) {
  _inheritsLoose(ScrollTrigger2, _Provider);
  function ScrollTrigger2(props) {
    var _this;
    _this = _Provider.call(this, props) || this;
    _this.scrollTrigger = null;
    _this.targets = {};
    _this.getPlugin = _this.getPlugin.bind(_assertThisInitialized(_this));
    return _this;
  }
  var _proto = ScrollTrigger2.prototype;
  _proto.registerConsumer = function registerConsumer2(consumer) {
    this.context.registerConsumer(consumer);
  };
  _proto.componentDidMount = function componentDidMount() {
    var _this$props = this.props, children = _this$props.children, scrollTrigger = _objectWithoutPropertiesLoose(_this$props, ["children"]);
    if (!children) {
      this.scrollTrigger = import_ScrollTrigger.ScrollTrigger.create(scrollTrigger);
    }
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    if (this.scrollTrigger) {
      this.scrollTrigger.kill();
    }
  };
  _proto.getGSAP = function getGSAP() {
    return this.scrollTrigger;
  };
  _proto.getPlugin = function getPlugin(props, targets) {
    var triggerProp = props.trigger, scrollTrigger = _objectWithoutPropertiesLoose(props, ["children", "trigger"]);
    var trigger = triggerProp;
    if (targets instanceof Map) {
      if (trigger) {
        var target = targets.get(trigger);
        if (target) {
          trigger = target;
        }
      } else {
        trigger = Array.from(targets.values());
      }
    } else if (!trigger) {
      trigger = targets;
    }
    return _extends({
      trigger
    }, scrollTrigger);
  };
  _proto.render = function render3() {
    var _this$props2 = this.props, children = _this$props2.children, scrollTrigger = _objectWithoutPropertiesLoose(_this$props2, ["children"]);
    if (!children) {
      return null;
    }
    return this.renderWithProvider(children, {
      scrollTrigger
    });
  };
  return ScrollTrigger2;
}(Provider);
ScrollTrigger.displayName = "ScrollTrigger";
ScrollTrigger.contextType = Context;
var escapeRegExp = function escapeRegExp2(regExp) {
  var specialChars = ["$", "^", "*", "(", ")", "+", "[", "]", "{", "}", "\\", "|", ".", "?", "/"];
  var regex = new RegExp("(\\" + specialChars.join("|\\") + ")", "g");
  return regExp.replace(regex, "\\$1");
};
var SplitWords = import_react.default.forwardRef(function(_ref, ref) {
  var children = _ref.children, wrapper = _ref.wrapper, _ref$delimiter = _ref.delimiter, delimiter = _ref$delimiter === void 0 ? " " : _ref$delimiter;
  if (typeof children !== "string") {
    throw new Error("SplitWords only accepts a string as child.");
  }
  var words = children.split(new RegExp("(" + escapeRegExp(delimiter) + ")", "g"));
  return import_react.default.createElement(import_react.default.Fragment, null, words.map(function(word, i) {
    if (delimiter === " " && word === delimiter) {
      return import_react.default.createElement(import_react.default.Fragment, {
        key: i
      }, " ");
    }
    return import_react.default.cloneElement(wrapper, {
      ref,
      key: i
    }, word);
  }));
});
var SplitChars = import_react.default.forwardRef(function(_ref2, ref) {
  var children = _ref2.children, wrapper = _ref2.wrapper;
  if (typeof children !== "string") {
    throw new Error("SplitChars only accepts a string as child.");
  }
  return import_react.default.createElement(import_react.default.Fragment, null, children.split(/(?=(?:[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]))/).map(function(_char, i) {
    if (_char === " ") {
      return import_react.default.createElement(import_react.default.Fragment, {
        key: i
      }, " ");
    }
    return import_react.default.cloneElement(wrapper, {
      ref,
      key: i
    }, _char);
  }));
});
var SplitLetters = import_react.default.forwardRef(function(props, ref) {
  console.warn("Deprecation warning: Use SplitChars instead of SplitLetters");
  return import_react.default.createElement(SplitChars, Object.assign({}, props, {
    ref
  }));
});
var Controls = function(_Provider) {
  _inheritsLoose(Controls2, _Provider);
  function Controls2() {
    var _this;
    _this = _Provider.apply(this, arguments) || this;
    _this.sliderTouched = false;
    _this.state = {
      totalProgress: 0,
      playState: void 0,
      prevPlayState: void 0
    };
    _this.containerStyle = {
      backgroundColor: "#f0f0f0",
      padding: "10px 10px 0 10px",
      marginTop: "10px",
      position: "relative",
      zIndex: 2,
      fontFamily: "verdana, sans-serif",
      fontSize: "16px",
      border: "1px solid #ccc"
    };
    _this.buttonContainerStyle = {
      margin: "0",
      display: "flex",
      flexWrap: "wrap",
      justifyContent: "space-between"
    };
    _this.buttonStyle = {
      border: "1px solid #999",
      backgroundColor: "#f0f0f0",
      padding: "5px",
      margin: "10px 10px 10px 0",
      cursor: "pointer"
    };
    _this.sliderStyle = {
      margin: "0",
      width: "100%"
    };
    _this.playStateStyle = {
      color: "#999",
      margin: "10px 0",
      fontSize: "14px"
    };
    _this.onUpdate = function() {
      if (_this.gsap && _this.slider && !_this.sliderTouched) {
        var totalProgress = _this.gsap.getGSAP().totalProgress();
        _this.slider.value = totalProgress * 100;
      }
    };
    _this.onChange = function(event) {
      if (_this.gsap && _this.gsap.getGSAP()) {
        _this.gsap.getGSAP().totalProgress(event.target.value / 100);
      }
    };
    _this.setPlayState = function(state) {
      _this.setState(function(prevState) {
        return {
          playState: state,
          prevPlayState: prevState.playState
        };
      });
    };
    _this.getControls = function(_totalProgress, playState) {
      return import_react.default.createElement("div", {
        style: _this.containerStyle
      }, import_react.default.createElement("input", {
        ref: function ref(el) {
          return _this.slider = el;
        },
        type: "range",
        style: _this.sliderStyle,
        step: "0.001",
        onChange: function onChange(e) {
          return _this.onChange(e);
        },
        onMouseDown: function onMouseDown() {
          return _this.sliderTouched = true;
        },
        onMouseUp: function onMouseUp() {
          return _this.sliderTouched = false;
        }
      }), import_react.default.createElement("div", {
        style: _this.buttonContainerStyle
      }, import_react.default.createElement("div", null, import_react.default.createElement("button", {
        type: "button",
        style: _this.buttonStyle,
        onClick: function onClick() {
          return _this.setPlayState(PlayState.play);
        }
      }, "Play"), import_react.default.createElement("button", {
        type: "button",
        style: _this.buttonStyle,
        onClick: function onClick() {
          return _this.setPlayState(PlayState.reverse);
        }
      }, "Reverse"), import_react.default.createElement("button", {
        type: "button",
        style: _this.buttonStyle,
        onClick: function onClick() {
          return _this.setPlayState(PlayState.pause);
        }
      }, "Pause"), import_react.default.createElement("button", {
        type: "button",
        style: _this.buttonStyle,
        onClick: function onClick() {
          return _this.setPlayState(PlayState.stop);
        }
      }, "Stop")), import_react.default.createElement("span", {
        style: _this.playStateStyle
      }, playState)));
    };
    return _this;
  }
  var _proto = Controls2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    if (this.consumers.length) {
      this.gsap = this.consumers[0];
      var gsap2 = this.gsap.getGSAP();
      if (gsap2) {
        gsap2.eventCallback("onUpdate", this.onUpdate);
        if (this.props.playState) {
          this.setPlayState(this.props.playState);
        } else {
          if (gsap2.paused()) {
            this.setPlayState(PlayState.pause);
          } else if (gsap2.reversed()) {
            this.setPlayState(PlayState.reverse);
          } else {
            this.setPlayState(PlayState.play);
          }
        }
        var totalProgress = gsap2.totalProgress();
        this.slider.value = totalProgress * 100;
      }
    }
  };
  _proto.componentDidUpdate = function componentDidUpdate() {
    this.onUpdate();
  };
  _proto.render = function render3() {
    var children = this.props.children;
    var _this$state = this.state, totalProgress = _this$state.totalProgress, playState = _this$state.playState, prevPlayState = _this$state.prevPlayState;
    if (this.gsap) {
      setPlayState(playState, prevPlayState, this.gsap.getGSAP());
    }
    return this.renderWithProvider(import_react.default.createElement("div", null, children, this.getControls(totalProgress, playState)));
  };
  return Controls2;
}(Provider);
export {
  Controls,
  PlayState,
  Reveal,
  ScrollTrigger,
  SplitChars,
  SplitLetters,
  SplitWords,
  Timeline,
  Tween
};
/*!
 * Observer 3.10.4
 * https://greensock.com
 *
 * @license Copyright 2008-2022, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
/*!
 * ScrollTrigger 3.10.4
 * https://greensock.com
 *
 * @license Copyright 2008-2022, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
//# sourceMappingURL=react-gsap.js.map
